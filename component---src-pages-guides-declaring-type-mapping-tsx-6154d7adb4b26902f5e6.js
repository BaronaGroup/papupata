(self.webpackChunkpapupata_docs=self.webpackChunkpapupata_docs||[]).push([[2801],{1040:function(e,t,n){"use strict";n.d(t,{P:function(){return a}});var a=n(7294).createContext(!1)},1724:function(e,t,n){"use strict";n.d(t,{$0:function(){return f},OT:function(){return v},ag:function(){return P},cY:function(){return q},l1:function(){return I},aE:function(){return A},d2:function(){return T},pR:function(){return x},by:function(){return F},yV:function(){return k},en:function(){return S},iT:function(){return D},Vo:function(){return N},lS:function(){return O}});var a,r,l,i,o,s,u,p,h,c=n(5761),d=n(3583),m=n(7294),y=n(1808),g=n(1040),Z=n(3431),f=d.ZP.section(a||(a=(0,c.Z)([""]))),v=d.ZP.h4(r||(r=(0,c.Z)([""]))),b=d.ZP.h5(l||(l=(0,c.Z)([""]))),w=d.ZP.section(i||(i=(0,c.Z)(["\n  padding: 15px 30px;\n  background: lightyellow;\n"]))),P=function(e){var t=e.children;return(0,Z.tZ)(f,null,(0,Z.tZ)(v,null,"Purpose"),t)},q=function(e){var t=e.version;return(0,Z.tZ)(f,null,(0,Z.tZ)(v,null,"Availability"),"This functionality is available from papupata version ",t," onwards.")},I=function(e){var t=e.children;return(0,Z.tZ)(f,null,(0,Z.tZ)(v,null,"Usage"),t)},A=function(e){var t=e.children,n=e.includeAvailableFrom,a=e.label;return(0,Z.tZ)(f,null,(0,Z.tZ)(g.P.Provider,{value:!!n},(0,Z.tZ)(v,null,"Parameters",a&&": "+a),t?(0,Z.tZ)("table",null,(0,Z.tZ)("thead",null,(0,Z.tZ)("tr",null,(0,Z.tZ)("th",null,"Name"),(0,Z.tZ)("th",null,"Type"),(0,Z.tZ)("th",null,"Description"),n&&(0,Z.tZ)("th",null,"Introduced in"))),(0,Z.tZ)("tbody",null,t)):(0,Z.tZ)("p",null,"There are no parameters.")))},T=function(e){var t=e.children,n=e.name,a=e.dataType,r=e.availableFrom,l=void 0===r?"1.0.0":r,i=m.useContext(g.P);return(0,Z.tZ)("tr",null,(0,Z.tZ)("td",null,n),(0,Z.tZ)("td",null,a),(0,Z.tZ)("td",null,t),i&&(0,Z.tZ)("td",null,l))},x=function(e){var t=e.children;return(0,Z.tZ)(f,null,(0,Z.tZ)(v,null,"Returns"),t)},F=function(e){var t=e.children;return(0,Z.tZ)(f,null,(0,Z.tZ)(v,null,"Caveats"),t)},k=function(e){var t=e.children;return(0,Z.tZ)(f,null,(0,Z.tZ)(v,null,"Examples"),t)},S=function(e){var t=e.children,n=e.label;return(0,Z.tZ)(m.Fragment,null,n&&(0,Z.tZ)(b,null,n),(0,Z.tZ)(y.E,{language:"typescript"},t))},D=function(e){var t=e.children;return(0,Z.tZ)(w,null,(0,Z.tZ)(b,null,"Common to examples below:"),t)},N=function(e){var t=e.children,n=e.includeAvailableFrom;return(0,Z.tZ)(f,null,(0,Z.tZ)(v,null,"Type parameeters"),(0,Z.tZ)(g.P.Provider,{value:!!n},(0,Z.tZ)(v,null,"Parameters"),t?(0,Z.tZ)("table",null,(0,Z.tZ)("thead",null,(0,Z.tZ)("tr",null,(0,Z.tZ)("th",null,"Name"),(0,Z.tZ)("th",null,"Default value"),(0,Z.tZ)("th",null,"Description"),n?(0,Z.tZ)("th",null,"Introduced in"):"")),(0,Z.tZ)("tbody",null,t)):(0,Z.tZ)("p",null,"There are no parameters.")))},C=d.ZP.tr(o||(o=(0,c.Z)([""]))),E=d.ZP.td(s||(s=(0,c.Z)([""]))),j=d.ZP.td(u||(u=(0,c.Z)([""]))),G=d.ZP.td(p||(p=(0,c.Z)([""]))),B=d.ZP.td(h||(h=(0,c.Z)([""]))),O=function(e){var t=e.children,n=e.name,a=e.defaultValue,r=e.availableFrom,l=void 0===r?"none":r,i=m.useContext(g.P);return(0,Z.tZ)(C,null,(0,Z.tZ)(E,null,n),(0,Z.tZ)(j,null,a),(0,Z.tZ)(G,null,t),i?(0,Z.tZ)(B,null,l):"")}},5361:function(e,t,n){"use strict";n.d(t,{g2:function(){return p},eC:function(){return d},If:function(){return m}});var a,r,l,i=n(5761),o=(n(7294),n(1724)),s=n(3583),u=n(3431);function p(e){var t=e.children;return(0,u.tZ)(o.$0,null,(0,u.tZ)(o.OT,null,"Overview"),t)}var h=s.ZP.h4(a||(a=(0,i.Z)([""]))),c=s.ZP.h5(r||(r=(0,i.Z)(["\n  font-size: 1.1em;\n"])));function d(e){var t=e.content;return(0,u.tZ)("div",null,(0,u.tZ)(o.$0,null,(0,u.tZ)(o.OT,null,"Table of contents"),(0,u.tZ)("ul",null,t.map((function(e){return(0,u.tZ)("li",{style:{marginLeft:18*(e.level||0)},key:e.anchor},(0,u.tZ)("a",{href:"#"+e.anchor},e.heading))})))),t.map((function(e){var t=e.level?c:h;return(0,u.tZ)(o.$0,{id:e.anchor,key:e.anchor},(0,u.tZ)(t,null,e.heading),e.content)})))}var m=s.ZP.span(l||(l=(0,i.Z)(["\n  font-family: 'Consolas', 'Bitstream Vera Sans Mono', 'Courier New', Courier, monospace;\n"])))},5586:function(e,t,n){"use strict";n.r(t);n(1879);var a=n(5444),r=n(7294),l=n(1724),i=n(832),o=n(5361),s=n(7614),u=n(7100),p=n(3431);t.default=function(){return(0,p.tZ)(u.Z,null,(0,p.tZ)(s.Z,null,(0,p.tZ)(i.Z,null,(0,p.tZ)("h1",null,"Guide: Typed query and path parameters"),(0,p.tZ)(o.g2,null,"Query parameters and path parameters are naturally strings. But that doesn't mean that it's all they can be, and the major addition to papupata 2.0 is support for types in query and path parameters."),(0,p.tZ)(l.cY,{version:"2.0.0"}),(0,p.tZ)(o.eC,{content:[{heading:"Prerequisites",anchor:"prerequisites",content:(0,p.tZ)(r.Fragment,null,(0,p.tZ)("p",null,"Before starting this guide, you need to have an API declaration, with declared APIs. For information on how to get there, see ",(0,p.tZ)(a.rU,{to:"/guides/declaring"},"Declaring APIs"),"."),(0,p.tZ)("p",null,"For the examples in the guide, the following code is assumed to be present in the scope:"),(0,p.tZ)(l.en,null,"\n                    import { APIDeclaration } from 'papupata'\n                    const API = new APIDeclaration()\n                  "))},{heading:"Basics",anchor:"basics",content:(0,p.tZ)(r.Fragment,null,(0,p.tZ)("p",null,"To begin with, you should know that this guide as well as other documentation for papupata refer to a concept called type mapping. These are javascript objects that are used to map fields to their types. For example"),(0,p.tZ)(l.en,null,"\n                  const myMapping = {\n                    name: String,\n                    age: Number\n                  }\n                "),(0,p.tZ)("p",null,"is a type mapping that declares name to be a string, and age to be a number."),(0,p.tZ)("p",null,"These type mappings are used for setting up the types for query and path parameters, for example"),(0,p.tZ)(l.en,null,"\n                    const api = API.declareGetAPI('/user/:id')\n                      .params({id: Number})\n                      .query({token: String})\n                      .optionalQuery({includeRelations: Boolean, maxLogEnties: Number})\n                      .response<any>()\n                  "),(0,p.tZ)("p",null,"Something that applies to all non-array types is that if a query parameter is specified multiple times, it will be its last instance that is used. This was chosen so that you can override values earlier in the URL just by appending a new value at the end of it."))},{heading:"Strings",anchor:"string",content:(0,p.tZ)(r.Fragment,null,(0,p.tZ)("p",null,"Strings are just about as simple as it gets. A path or query parameter is a string, and it's passed to the implementation as provided."),(0,p.tZ)(l.en,null,"\n                    const api = API.declareGetAPI('/path')\n                      .query({param: String})\n                      .response<any>()\n                  "))},{heading:"Enumerations",anchor:"enum",level:1,content:(0,p.tZ)(r.Fragment,null,(0,p.tZ)("p",null,"Sometimes a string is not just any string. Enumerations are a common thing, and you might want to have your query parameter be one from a specific set of strings. This is something papupata supports, using its StringEnum type."),(0,p.tZ)(l.en,null,"\n                    import { StringEnum } from 'papupata/queryTypes'\n\n                    const api = API.declareGetAPI('/path')\n                      .query({param: StringEnum(['alpha', 'beta'] as const)})\n                      .response<any>()\n                  "),(0,p.tZ)("p",null,"Typescript is fully aware of the enumeration nature of the parameter on both the client and server sides, and the value is validated by papupata before it is passed to the route implementation on the server."),(0,p.tZ)("p",null,"Do make sure to include the ",(0,p.tZ)(o.If,null,"as const")," after the array declaration; if omitted, the field will be treated by typescript as just a string, so the only benefit you get is the validation done by papupata."))},{heading:"Regex-constrained",anchor:"regex",level:1,content:(0,p.tZ)(r.Fragment,null,(0,p.tZ)("p",null,"Regular expressions are an effective way to validate strings while providing a reasonable way for clients to figure out if they have something valid or not. Papupata has a support for constraining a string parameter to match a regular expression, though it must be noted that typescript will treat is just as any string, so it is not able to indicate incorrect usage."),(0,p.tZ)(l.en,null,"\n              import { StringMatching } from 'papupata/queryTypes'\n\n              const api = API.declareGetAPI('/path')\n                .query({param: StringMatching(/^[A-Z]{8}$/)})\n                .response<any>()\n            "))},{heading:"Numbers",anchor:"numbers",content:(0,p.tZ)(r.Fragment,null,(0,p.tZ)("p",null,"It is very common to include numbers as query parameters, for features such as paging. Numbers are fully supported as query and path parameters in papupata."),(0,p.tZ)(l.en,null,"\n                  const api = API.declareGetAPI('/path')\n                    .query({param: Number})\n                    .response<any>()\n\n                  api({param: 100})\n\n                  api.implement(req => console.log(typeof req.query.param)) // outputs number\n                "),(0,p.tZ)("p",null,"Typescript is also aware of the parameter being a number helping with the correct usage of the API."),(0,p.tZ)("p",null,"Do be aware that the two special numbers in javascript, Infinity and NaN are both valid values for a number parameter!"))},{heading:"Integers",anchor:"integers",level:1,content:(0,p.tZ)(r.Fragment,null,(0,p.tZ)("p",null,'Integers as are undoubtedly the most common form of numbers you see in query parameters, so support for them as a special case was added to papupata although typescript will only ever see them as the normal "number" type.'),(0,p.tZ)(l.en,null,"\n            const api = API.declareGetAPI('/path')\n              .query({param: Integer})\n              .response<any>()\n\n            api({param: 100})\n\n            api.implement(req => console.log(typeof req.query.param)) // outputs number\n          "),(0,p.tZ)("p",null,"This does mean that the only real effect that something being declared as an integer instead of a number has is papupata validating it differently before passing it to the implementation."),(0,p.tZ)("p",null,"Infinity and NaN are not considered to be integers."))},{heading:"Booleans",anchor:"booleans",content:(0,p.tZ)(r.Fragment,null,(0,p.tZ)("p",null,"Booleans are also fully supported in papupata, and typescript is knows perfectly well when a parameter is meant to be a boolean, too."),(0,p.tZ)(l.en,null,"\n            const api = API.declareGetAPI('/path')\n              .query({param: Boolean})\n              .response<any>()\n\n            api({param: true})\n\n            api.implement(req => console.log(typeof req.query.param)) // outputs boolean\n          "),(0,p.tZ)("p",null,'The server side accepts only the string "true" to indicate the boolean true, whereas false can be indicated both by the string "false" and an empty string. All other values are invalid.'))},{heading:"Dates",anchor:"dates",content:(0,p.tZ)(r.Fragment,null,(0,p.tZ)("p",null,"Dates are not the most common thing you see in query parameters, but they are supported as well. On the client a date must be provided as a Date object, a string will not do. On the server side the input is passed to the date constructor, and if the resulting date is invalid, the parameter is considered to be invalid. For consistent results, ISO 8601 format is recommended."),(0,p.tZ)(l.en,null,"\n                    const api = API.declareGetAPI('/path')\n                      .query({param: Date})\n                      .response<any>()\n\n                    api({param: new Date()})\n\n                    api.implement(req => console.log(req.query.param instanceof Date)) // outputs true\n                  "))},{heading:"Arrays",anchor:"arrays",content:(0,p.tZ)(r.Fragment,null,(0,p.tZ)("p",null,"In query parameter context arrays of all of the types above are supported. In the declaration you indicate an array by putting the type inside an array."),(0,p.tZ)(l.en,null,"\n                    const api = API.declareGetAPI('/path')\n                      .query({param: [Number]})\n                      .response<any>()\n\n                    api({param: [1, 2, 3]})\n\n                    api.implement(req => console.log(Array.isArray(req.query.param), req.query.param.length) // outputs true, 3\n                  "),(0,p.tZ)("p",null,"The usage is as one would expect, with arrays being used on the client side and arrays being received at the server side."),(0,p.tZ)("p",null,"On HTTP level the arrays are passed as multiple parameters with the same name, and they become array entries in the same order as they are in the URL."),(0,p.tZ)("p",null,"One oddity of arrays is that they are always effectively optional as far as the server is concerned, as lack of any values creates an empty array, while the array is required to be entered on the browser side. If the array is used in"," ",(0,p.tZ)(o.If,null,"optionalQuery"),", typescript is actually aware on the server of there always being an array, so there is no need to check for it possibly being undefined."))},{heading:"Validation",anchor:"validation",content:(0,p.tZ)(r.Fragment,null,(0,p.tZ)("p",null,"Query and path parameters are always validated to ensure that they match the expected type and any other constraints there may be. By default validation failure triggers an error, though you can configure papupata or the individual API to do rerouting instead."))},{heading:"Error handling",anchor:"errorhandling",level:1,content:(0,p.tZ)(r.Fragment,null,(0,p.tZ)("p",null,"Upon a validation failure, an error of the type PapupataValidationError (importable from papupata/ValidationError) is thrown. This can be caught and processed in either inherent papupata middleware or in express error handling middleware."))},{heading:"Routing decisions",anchor:"rerouting",level:1,content:(0,p.tZ)(r.Fragment,null,(0,p.tZ)("p",null,"The other option is to trigger rerouting upon validation failure. This allows you to have multiple APIs that have the same URL, such that routing depends on the values of query and path parameters."),(0,p.tZ)("p",null,"What basically happens is that express is told that the route it attempted to use is incorrect and that it should see if there are any other routes that match the request."))},{heading:"Middleware",anchor:"middleware",content:(0,p.tZ)(r.Fragment,null,(0,p.tZ)("p",null,"The timing for validating and converting the parameters is very specific: it takes place after inherent middleware and before route-specific middleware."),(0,p.tZ)("p",null,"This has been done so that any generic middleware is present even when validation fails, allowing logging, for example to work correctly, but with the assumption that route-specific middleware might expect the types to already have been taken care of (numbers for example being actual numbers and not just strings)."))}]}))))}},1879:function(e,t,n){"use strict";n(7614),n(832),n(7100)}}]);
//# sourceMappingURL=component---src-pages-guides-declaring-type-mapping-tsx-6154d7adb4b26902f5e6.js.map