{"version":3,"sources":["webpack:///./src/pages/guides/client/testing.tsx","webpack:///./src/components/guides.tsx","webpack:///./node_modules/core-js/modules/es6.string.anchor.js"],"names":["IndexPage","content","heading","anchor","to","Overview","children","Level0","styled","h4","Level1","h5","GuideContent","map","child","style","marginLeft","level","key","href","Heading","id","FixedFont","span","createHTML","name","this"],"mappings":"2FAAA,8EAyLeA,UAhLG,kBAChB,YAAC,IAAD,KACE,YAAC,IAAD,KACE,YAAC,IAAD,KACE,6CACA,YAAC,IAAD,sHACA,YAAC,IAAD,CACEC,QAAS,CACP,CACEC,QAAS,gBACTC,OAAQ,gBACRF,QACE,4BACE,sJAEa,YAAC,IAAD,CAAMG,GAAI,qBAAV,kBAFb,0GAG+C,YAAC,IAAD,CAAMA,GAAI,wBAAV,wBAE/C,kLAIA,YAAC,IAAD,mSAUN,CACEF,QAAS,WACTC,OAAQ,WACRF,QACE,4BACE,mRAKA,+MAON,CACEC,QAAS,aACTC,OAAQ,SACRF,QACE,4BACE,mGAC6E,YAAC,IAAD,aAD7E,IAC0G,IACxG,YAAC,IAAD,iBAFF,QAEsC,YAAC,IAAD,eAFtC,oHAKA,4BACM,YAAC,IAAD,aADN,QACsC,YAAC,IAAD,iBADtC,8BACiG,IAC/F,YAAC,IAAD,aAFF,qDAE+E,YAAC,IAAD,iBAAgC,IAF/G,8GAKA,gHACA,YAAC,IAAD,2LAKA,2VAKA,YAAC,IAAD,0MAKA,YAAC,IAAD,0LAKA,+DACyC,YAAC,IAAD,kBADzC,+FAE4C,YAAC,IAAD,iBAF5C,kKAKA,YAAC,IAAD,mFAGA,8GACA,YAAC,IAAD,iEAMN,CACEC,QAAS,4BACTC,OAAQ,YACRF,QACE,4BACE,iXAKA,YAAC,IAAD,8QAMA,YAAC,IAAD,iRAMA,0IAIN,CACEC,QAAS,+BACTC,OAAQ,iBACRF,QACE,4BACE,4RAKA,4IACuH,IACrH,YAAC,IAAD,aAFF,OAEiC,YAAC,IAAD,iBAFjC,0BAEwF,IACtF,YAAC,IAAD,sCAHF,uOAOA,YAAC,IAAD,mUASN,CACEC,QAAS,aACTC,OAAQ,aACRF,QACE,4BACE,4JAIA,qEAEE,YAAC,IAAD,CAAMG,GAAG,wBAAT,8BAFF,OAEwE,IACtE,YAAC,IAAD,CAAMA,GAAG,+BAAT,qBAHF,qC,qgBCtKX,SAASC,EAAT,GAAyD,IAArCC,EAAqC,EAArCA,SACzB,OACE,YAAC,IAAD,KACE,YAAC,IAAD,iBACCA,GAYP,IAAMC,EAASC,IAAOC,GAAV,KACNC,EAAQF,IAAOG,GAAT,KAIL,SAASC,EAAT,GAA6D,IAArCX,EAAqC,EAArCA,QAC7B,OACE,uBACE,YAAC,IAAD,KACE,YAAC,IAAD,0BACA,sBACGA,EAAQY,KAAI,SAAAC,GAAK,OAChB,kBAAIC,MAAO,CAAEC,WAAY,IAAMF,EAAMG,OAAS,IAAMC,IAAKJ,EAAMX,QAC7D,iBAAGgB,KAAI,IAAML,EAAMX,QAAWW,EAAMZ,eAK3CD,EAAQY,KAAI,SAAAC,GACX,IAAMM,EAAWN,EAAMG,MAAiBP,EAATH,EAC/B,OACE,YAAC,IAAD,CAASc,GAAIP,EAAMX,OAAQe,IAAKJ,EAAMX,QACpC,YAACiB,EAAD,KAAUN,EAAMZ,SACfY,EAAMb,aAQZ,IAAMqB,EAAYd,IAAOe,KAAV,M,iCCjDtB,EAAQ,IAAR,CAA0B,UAAU,SAAUC,GAC5C,OAAO,SAAgBC,GACrB,OAAOD,EAAWE,KAAM,IAAK,OAAQD","file":"component---src-pages-guides-client-testing-tsx-c8a63575d9ab11441505.js","sourcesContent":["import * as React from 'react'\n\nimport Page from '../../../components/Page'\nimport Container from '../../../components/Container'\nimport IndexLayout from '../../../layouts'\nimport { FixedFont, GuideContent, Overview } from '../../../components/guides'\nimport { Example } from '../../../components/api-components'\nimport { Link } from 'gatsby'\n\nconst IndexPage = () => (\n  <IndexLayout>\n    <Page>\n      <Container>\n        <h1>Guide: testing APIs</h1>\n        <Overview>Testing and mocking are often tricky things. Papupata offers its own mocking functionality to make it easier.</Overview>\n        <GuideContent\n          content={[\n            {\n              heading: 'Prerequisites',\n              anchor: 'prerequisites',\n              content: (\n                <>\n                  <p>\n                    Before starting this guide, you need to have an API declaration, with declared APIs. For information on how to get\n                    there, see <Link to={'/guides/declaring'}>Declaring APIs</Link>. You also need to have configured the API declaration to\n                    be able to make requests. This is covered in <Link to={'/guides/client/setup'}>Setting up papupata</Link>\n                  </p>\n                  <p>\n                    For the examples in the guide, the following code is assumed to be present in the scope, and by this time you should be\n                    fully aware of what it all means:\n                  </p>\n                  <Example>{`\n                    const API = new APIDeclaration()\n                    const api = API.declarePatchAPI('/update/:id')\n                      .params(['id'] as const)\n                      .body<{name: string}>()\n                      .response<string>()\n                  `}</Example>\n                </>\n              )\n            },\n            {\n              heading: 'Foreword',\n              anchor: 'foreword',\n              content: (\n                <>\n                  <p>\n                    To begin with, you absolutely can the functionality provided by various testing libraries with papupata. You can just\n                    jest mocks to mock the calls to APIs, you can do the same with sinon. Or you can nock to intercept the requests that\n                    papupata makes.\n                  </p>\n                  <p>\n                    These are all fine options, and if you are comfortable using them, by all means do. Just be aware that this guide mostly\n                    just covers the built-in mocking functionality of papupata.\n                  </p>\n                </>\n              )\n            },\n            {\n              heading: 'The Basics',\n              anchor: 'basics',\n              content: (\n                <>\n                  <p>\n                    All APIs declared with papupata expose three methods to help with testing: <FixedFont>mock</FixedFont>,{' '}\n                    <FixedFont>mockOnce</FixedFont> and <FixedFont>unmock</FixedFont>. Their purpose is simple: to help you temporarily have\n                    the API call do something other than an actual API call.\n                  </p>\n                  <p>\n                    The <FixedFont>mock</FixedFont> and <FixedFont>mockOnce</FixedFont> functions do exactly that.{' '}\n                    <FixedFont>mock</FixedFont> changes the behavior until it is undone, whereas <FixedFont>mockOnce</FixedFont>{' '}\n                    automatically undoes itself after the first call. Everything from now on applies to both of the functions.\n                  </p>\n                  <p>The simplest mock is one that returns a fixed value. Making that happen is simple, too:</p>\n                  <Example>{`\n                    api.mock('mockValue')\n                    const value = await api({id: '1', name: 'Maija'})\n                    // value === mockValue\n                  `}</Example>\n                  <p>\n                    Sometimes you might need more control, and for that purpose the mock functions also accept functions as their\n                    parameters. The function should return a value that is either of the type returned by the API, or a promise of one, or\n                    they should throw. The function is given the arguments to the API call as the sole parameter.\n                  </p>\n                  <Example>{`\n                    api.mock(args => args.name + args.id)\n                    const value = await api({id: '1', name: 'Maija'})\n                    // value === 'Maija1'\n                  `}</Example>\n                  <Example>{`\n                    api.mock(() => {throw new Error()})\n                    await api({id: '1', name: 'Maija'})\n                    // simulating failure\n                  `}</Example>\n                  <p>\n                    It is generally recommended to have an <FixedFont>afterEach</FixedFont> to undo all the mocks for any tests that utilize\n                    papupata mocking. Even though you can use <FixedFont>mockOnce</FixedFont> to only mock an API for a single invocation,\n                    if a test fail in such a way that the invocation never happens you might have a hard-to-track bug in your hands.\n                  </p>\n                  <Example>{`\n                    afterEach(() => API.unmockAll())\n                  `}</Example>\n                  <p>You can also unmock individual APIs, though that tends to be less useful in practice.</p>\n                  <Example>{`\n                    api.unmock()\n                  `}</Example>\n                </>\n              )\n            },\n            {\n              heading: 'Using sinon or jest mocks',\n              anchor: 'sinonjest',\n              content: (\n                <>\n                  <p>\n                    If you are familiar with sinon stubs and jest.fn, you might already have started considering the potential given by\n                    passing in any function as a mock. You absolutely can and should pass functions from these libraries as the mocks\n                    whenever it suits your needs, for example to verify that the mock was called with the arguments that you expected.\n                  </p>\n                  <Example>{`\n                    const stub = sinon.stub().resolves('test')\n                    api.mock(stub)\n                    await api({id: '1', name: 'Maija'})\n                    sinon.assert.calledWithExactly(stub, {id: '1', name: 'Maija'})\n                  `}</Example>\n                  <Example>{`\n                    const mock = jest.fn().mockResolvedValue('test')\n                    api.mock(mock)\n                    await api({id: '1', name: 'Maija'})\n                    expect(mock).toHaveBeenCalledWith({id: '1', name: 'Maija'})\n                  `}</Example>\n                  <p>Sinon in particular can be handy if you need to mock multiple invocations to the API, with different responses.</p>\n                </>\n              )\n            },\n            {\n              heading: 'Dealing with separate bodies',\n              anchor: 'separateBodies',\n              content: (\n                <>\n                  <p>\n                    As you might recall, it is possible to pass the body as a separate parameter to the API invocation. And in many cases it\n                    is impossible to combine it with the other parameters, for example if the body is a string. This does have an effect on\n                    the mocks as well.\n                  </p>\n                  <p>\n                    If you want to mock a call like this in such a way that you gain access to the body, you have to pass options to the{' '}\n                    <FixedFont>mock</FixedFont> or <FixedFont>mockOnce</FixedFont> functions. If you pass{' '}\n                    <FixedFont>{`{includeBodySeparately: true}`}</FixedFont> as a second parameter to the mock function, the mock function\n                    passed to be the mock is always given a second parameter, which is the body. If the body is an object, its fields are\n                    incorporated into the first parameter as well.\n                  </p>\n                  <Example>{`\n                    const mock = jest.fn().mockResolvedValue('test')\n                    api.mock(mock, {includeBodySeparately: true})\n                    await api({id: '1', name: 'Maija'})\n                    expect(mock).toHaveBeenCalledWith({id: '1', name: 'Maija'}, {name: 'Maija'})\n                  `}</Example>\n                </>\n              )\n            },\n            {\n              heading: 'Conclusion',\n              anchor: 'conclusion',\n              content: (\n                <>\n                  <p>\n                    Now you know how to test API calls made using papupata and should by now have pretty much mastered how to use papupata\n                    as a client.\n                  </p>\n                  <p>\n                    If you want to switch to the server side now,\n                    <Link to=\"/guides/server/setup\">setting up papupata server</Link> and{' '}\n                    <Link to=\"/guides/server/implementing\">implementing APIs</Link> are both fine options.\n                  </p>\n                </>\n              )\n            }\n          ]}\n        />\n      </Container>\n    </Page>\n  </IndexLayout>\n)\n\nexport default IndexPage\n","import React, { ReactNode } from 'react'\nimport { Section, SectionHeading } from './api-components'\nimport styled from 'styled-components'\n\nexport function Overview({ children }: { children: ReactNode }) {\n  return (\n    <Section>\n      <SectionHeading>Overview</SectionHeading>\n      {children}\n    </Section>\n  )\n}\n\ninterface GuidePart {\n  heading: ReactNode\n  anchor: string\n  content: ReactNode\n  level?: number\n}\n\nconst Level0 = styled.h4``\nconst Level1= styled.h5`\n  font-size: 1.1em;\n`\n\nexport function GuideContent({ content }: { content: GuidePart[] }) {\n  return (\n    <div>\n      <Section>\n        <SectionHeading>Table of contents</SectionHeading>\n        <ul>\n          {content.map(child => (\n            <li style={{ marginLeft: 18 * (child.level || 0) }} key={child.anchor}>\n              <a href={`#${child.anchor}`}>{child.heading}</a>\n            </li>\n          ))}\n        </ul>\n      </Section>\n      {content.map(child => {\n        const Heading = !child.level ? Level0 : Level1\n        return (\n          <Section id={child.anchor} key={child.anchor}>\n            <Heading>{child.heading}</Heading>\n            {child.content}\n          </Section>\n        )\n      })}\n    </div>\n  )\n}\n\nexport const FixedFont = styled.span`\n  font-family: \"Consolas\", \"Bitstream Vera Sans Mono\", \"Courier New\", Courier, monospace\n`\n","'use strict';\n// B.2.3.2 String.prototype.anchor(name)\nrequire('./_string-html')('anchor', function (createHTML) {\n  return function anchor(name) {\n    return createHTML(this, 'a', 'name', name);\n  };\n});\n"],"sourceRoot":""}