{"version":3,"sources":["webpack:///./src/components/IncludeAvailableFromContext.tsx","webpack:///./src/components/api-components.tsx","webpack:///./src/pages/guides/server/setup.tsx","webpack:///./src/components/guides.tsx"],"names":["IncludeAvailableFromContext","React","Section","styled","section","SectionHeading","h4","SubHeading","h5","ExampleCommonContainer","Purpose","children","AvailableFrom","version","Usage","Parameters","includeAvailableFrom","label","Provider","value","Parameter","name","dataType","availableFrom","useContext","MethodReturnType","Caveats","Examples","Example","language","ExampleCommon","TypeParameters","Row","tr","NameColumn","td","DefaultValueColumn","DescriptionColumn","AvailableFromColumn","TypeParameter","defaultValue","IndexPage","content","heading","anchor","to","Overview","Level0","Level1","GuideContent","map","child","style","marginLeft","level","key","href","Heading","id","FixedFont","span"],"mappings":"8FAAA,kDAEaA,EAA8BC,iBAAoB,I,qvCCGxD,IAAMC,EAAUC,IAAOC,QAAV,KACPC,EAAiBF,IAAOG,GAAV,KACdC,EAAaJ,IAAOK,GAAV,KACVC,EAAyBN,IAAOC,QAAV,KAKtBM,EAAoB,SAAC,GAAiB,IAAfC,EAAe,EAAfA,SAClC,OACE,YAACT,EAAD,KACE,YAACG,EAAD,gBACCM,IAMMC,EAAgB,SAAC,GAA4C,IAA1CC,EAA0C,EAA1CA,QAC9B,OACE,YAACX,EAAD,KACE,YAACG,EAAD,qBADF,yDAEyDQ,EAFzD,cAOSC,EAAkB,SAAC,GAAiB,IAAfH,EAAe,EAAfA,SAChC,OACE,YAACT,EAAD,KACE,YAACG,EAAD,cACCM,IAIMI,EAA2E,SAAC,GAA8C,IAA5CJ,EAA4C,EAA5CA,SAAUK,EAAkC,EAAlCA,qBAAsBC,EAAY,EAAZA,MACzH,OACE,YAACf,EAAD,KACE,YAAC,IAA4BgB,SAA7B,CAAsCC,QAASH,GAC7C,YAACX,EAAD,kBAA2BY,GAAS,KAAKA,GACxCN,EACC,yBACE,yBACE,sBACE,8BACA,8BACA,qCACCK,GAAwB,yCAG7B,yBAAQL,IAGV,oDAOGS,EAAsF,SAAC,GAK9F,IAJJT,EAII,EAJJA,SACAU,EAGI,EAHJA,KACAC,EAEI,EAFJA,SAEI,IADJC,qBACI,MADY,QACZ,EACEP,EAAuBf,IAAMuB,WAAWxB,KAC9C,OACE,sBACE,sBAAKqB,GACL,sBAAKC,GACL,sBAAKX,GACJK,GAAwB,sBAAKO,KAKvBE,EAA6B,SAAC,GAAiB,IAAfd,EAAe,EAAfA,SAC3C,OACE,YAACT,EAAD,KACE,YAACG,EAAD,gBACCM,IAKMe,EAAoB,SAAC,GAAiB,IAAff,EAAe,EAAfA,SAClC,OACE,YAACT,EAAD,KACE,YAACG,EAAD,gBACCM,IAIMgB,EAAwC,SAAC,GAAiB,IAAfhB,EAAe,EAAfA,SACtD,OACE,YAACT,EAAD,KACE,YAACG,EAAD,iBACCM,IAKMiB,EAA0D,SAAC,GAAwB,IAAtBjB,EAAsB,EAAtBA,SAAUM,EAAY,EAAZA,MAClF,OACE,8BACGA,GAAS,YAACV,EAAD,KAAaU,GACvB,YAAC,IAAD,CAAMY,SAAU,cAAelB,KAKxBmB,EAA6C,SAAC,GAAiB,IAAfnB,EAAe,EAAfA,SAC3D,OACE,YAACF,EAAD,KACE,YAACF,EAAD,kCACCI,IAKMoB,EAAoF,SAAC,GAAuC,IAArCpB,EAAqC,EAArCA,SAAUK,EAA2B,EAA3BA,qBAC5G,OACE,YAACd,EAAD,KACE,YAACG,EAAD,yBACA,YAAC,IAA4Ba,SAA7B,CAAsCC,QAASH,GAC7C,YAACX,EAAD,mBACCM,EACC,yBACE,yBACE,sBACE,8BACA,uCACA,qCACCK,EAAuB,uCAAyB,KAGrD,yBAAQL,IAGV,oDAOJqB,EAAM7B,IAAO8B,GAAV,KACHC,EAAa/B,IAAOgC,GAAV,KACVC,EAAqBjC,IAAOgC,GAAV,KAClBE,EAAoBlC,IAAOgC,GAAV,KACjBG,EAAsBnC,IAAOgC,GAAV,KAEZI,EAA2F,SAAC,GAKnG,IAJJ5B,EAII,EAJJA,SACAU,EAGI,EAHJA,KACAmB,EAEI,EAFJA,aAEI,IADJjB,qBACI,MADY,OACZ,EACEP,EAAuBf,IAAMuB,WAAWxB,KAC9C,OACE,YAACgC,EAAD,KACE,YAACE,EAAD,KAAab,GACb,YAACe,EAAD,KAAqBI,GACrB,YAACH,EAAD,KAAoB1B,GACnBK,EAAuB,YAACsB,EAAD,KAAsBf,GAAuC,M,kCC1K3F,2GAiPekB,UAxOG,kBAChB,YAAC,IAAD,KACE,YAAC,IAAD,KACE,YAAC,IAAD,KACE,gEACA,YAAC,IAAD,+MAIA,YAAC,IAAD,CACEC,QAAS,CACP,CACEC,QAAS,gBACTC,OAAQ,gBACRF,QACE,4BACE,wGACmF,IACjF,YAAC,IAAD,CAAMG,GAAI,qBAAV,kBAFF,wBAON,CACEF,QAAS,aACTC,OAAQ,SACRF,QACE,4BACE,mMAIA,uEACiD,YAAC,IAAD,kBADjD,kCAGA,YAAC,IAAD,mRAQA,YAAC,IAAD,4MAUN,CACEC,QAAS,iCACTC,OAAQ,YACRF,QACE,4BACE,YAAC,IAAD,+KAMA,oSAKA,iaAMA,YAAC,IAAD,6NAIA,sPAE2G,IACzG,YAAC,IAAD,6BAHF,8OAOA,2QAGS,YAAC,IAAD,oCAET,YAAC,IAAD,4JAON,CACEC,QAAS,WACTC,OAAQ,UACRF,QACE,4BACE,YAAC,IAAD,uLAMA,6JAEe,YAAC,IAAD,eAFf,yFAKA,yFAIN,CACEC,QAAS,mBACTC,OAAQ,UACRF,QACE,4BACE,YAAC,IAAD,qKAMA,kRAKA,sFACgE,YAAC,IAAD,iBADhE,iFAIA,4JAIA,YAAC,IAAD,mlBAmBN,CACEC,QAAS,aACTC,OAAQ,aACRF,QACE,4BACE,YAAC,IAAD,uMAMA,mJAEM,YAAC,IAAD,CAAMG,GAAG,6BAAT,wBAFN,KAIA,6PAKA,wOAIA,qEACA,sBACE,8JAIA,6EACA,yEAEF,YAAC,IAAD,urBAeN,CACEF,QAAS,aACTC,OAAQ,aACRF,QACE,4BACE,oIACA,4BACM,YAAC,IAAD,CAAMG,GAAG,+BAAT,qBADN,gCAGA,uJAEU,YAAC,IAAD,CAAMA,GAAG,yCAAT,4BAFV,e,2gBC/NX,SAASC,EAAT,GAAyD,IAArCnC,EAAqC,EAArCA,SACzB,OACE,YAAC,IAAD,KACE,YAAC,IAAD,iBACCA,GAYP,IAAMoC,EAAS5C,IAAOG,GAAV,KACN0C,EAAS7C,IAAOK,GAAV,KAIL,SAASyC,EAAT,GAA6D,IAArCP,EAAqC,EAArCA,QAC7B,OACE,uBACE,YAAC,IAAD,KACE,YAAC,IAAD,0BACA,sBACGA,EAAQQ,KAAI,SAACC,GAAD,OACX,kBAAIC,MAAO,CAAEC,WAAY,IAAMF,EAAMG,OAAS,IAAMC,IAAKJ,EAAMP,QAC7D,iBAAGY,KAAI,IAAML,EAAMP,QAAWO,EAAMR,eAK3CD,EAAQQ,KAAI,SAACC,GACZ,IAAMM,EAAWN,EAAMG,MAAiBN,EAATD,EAC/B,OACE,YAAC,IAAD,CAASW,GAAIP,EAAMP,OAAQW,IAAKJ,EAAMP,QACpC,YAACa,EAAD,KAAUN,EAAMR,SACfQ,EAAMT,aAQZ,IAAMiB,EAAYxD,IAAOyD,KAAV","file":"component---src-pages-guides-server-setup-tsx-0acf08cd601785c9e511.js","sourcesContent":["import * as React from 'react'\n\nexport const IncludeAvailableFromContext = React.createContext(false)\n","import styled from 'styled-components'\nimport React, { ReactNode } from 'react'\nimport { Code } from './Code'\nimport { IncludeAvailableFromContext } from './IncludeAvailableFromContext'\n\nexport const Section = styled.section``\nexport const SectionHeading = styled.h4``\nexport const SubHeading = styled.h5``\nexport const ExampleCommonContainer = styled.section`\n  padding: 15px 30px;\n  background: lightyellow;\n`\n\nexport const Purpose: React.FC = ({ children }) => {\n  return (\n    <Section>\n      <SectionHeading>Purpose</SectionHeading>\n      {children}\n    </Section>\n  )\n}\n\nexport type ValidVersions = '1.1.0' | '1.2.0' | '1.5.0' | '1.8.0'\nexport const AvailableFrom = ({ version }: { version: ValidVersions }) => {\n  return (\n    <Section>\n      <SectionHeading>Availability</SectionHeading>\n      This functionality is available from papupata version {version} onwards.\n    </Section>\n  )\n}\n\nexport const Usage: React.FC = ({ children }) => {\n  return (\n    <Section>\n      <SectionHeading>Usage</SectionHeading>\n      {children}\n    </Section>\n  )\n}\nexport const Parameters: React.FC<{ includeAvailableFrom?: boolean; label?: string }> = ({ children, includeAvailableFrom, label }) => {\n  return (\n    <Section>\n      <IncludeAvailableFromContext.Provider value={!!includeAvailableFrom}>\n        <SectionHeading>Parameters{label && `: ${label}`}</SectionHeading>\n        {children ? (\n          <table>\n            <thead>\n              <tr>\n                <th>Name</th>\n                <th>Type</th>\n                <th>Description</th>\n                {includeAvailableFrom && <th>Introduced in</th>}\n              </tr>\n            </thead>\n            <tbody>{children}</tbody>\n          </table>\n        ) : (\n          <p>There are no parameters.</p>\n        )}\n      </IncludeAvailableFromContext.Provider>\n    </Section>\n  )\n}\n\nexport const Parameter: React.FC<{ name: string; dataType: any; availableFrom?: ValidVersions }> = ({\n  children,\n  name,\n  dataType,\n  availableFrom = '1.0.0'\n}) => {\n  const includeAvailableFrom = React.useContext(IncludeAvailableFromContext)\n  return (\n    <tr>\n      <td>{name}</td>\n      <td>{dataType}</td>\n      <td>{children}</td>\n      {includeAvailableFrom && <td>{availableFrom}</td>}\n    </tr>\n  )\n}\n\nexport const MethodReturnType: React.FC = ({ children }) => {\n  return (\n    <Section>\n      <SectionHeading>Returns</SectionHeading>\n      {children}\n    </Section>\n  )\n}\n\nexport const Caveats: React.FC = ({ children }) => {\n  return (\n    <Section>\n      <SectionHeading>Caveats</SectionHeading>\n      {children}\n    </Section>\n  )\n}\nexport const Examples: React.FC<{ children: any }> = ({ children }) => {\n  return (\n    <Section>\n      <SectionHeading>Examples</SectionHeading>\n      {children}\n    </Section>\n  )\n}\n\nexport const Example: React.FC<{ label?: string; children: string }> = ({ children, label }) => {\n  return (\n    <>\n      {label && <SubHeading>{label}</SubHeading>}\n      <Code language={'typescript'}>{children}</Code>\n    </>\n  )\n}\n\nexport const ExampleCommon: React.FC<{ children: any }> = ({ children }) => {\n  return (\n    <ExampleCommonContainer>\n      <SubHeading>Common to examples below:</SubHeading>\n      {children}\n    </ExampleCommonContainer>\n  )\n}\n\nexport const TypeParameters: React.FC<{ children: ReactNode; includeAvailableFrom?: boolean }> = ({ children, includeAvailableFrom }) => {\n  return (\n    <Section>\n      <SectionHeading>Type parameeters</SectionHeading>\n      <IncludeAvailableFromContext.Provider value={!!includeAvailableFrom}>\n        <SectionHeading>Parameters</SectionHeading>\n        {children ? (\n          <table>\n            <thead>\n              <tr>\n                <th>Name</th>\n                <th>Default value</th>\n                <th>Description</th>\n                {includeAvailableFrom ? <th>Introduced in</th> : ''}\n              </tr>\n            </thead>\n            <tbody>{children}</tbody>\n          </table>\n        ) : (\n          <p>There are no parameters.</p>\n        )}\n      </IncludeAvailableFromContext.Provider>\n    </Section>\n  )\n}\n\nconst Row = styled.tr``\nconst NameColumn = styled.td``\nconst DefaultValueColumn = styled.td``\nconst DescriptionColumn = styled.td``\nconst AvailableFromColumn = styled.td``\n\nexport const TypeParameter: React.FC<{ name: string; defaultValue?: string; availableFrom?: string }> = ({\n  children,\n  name,\n  defaultValue,\n  availableFrom = 'none'\n}) => {\n  const includeAvailableFrom = React.useContext(IncludeAvailableFromContext)\n  return (\n    <Row>\n      <NameColumn>{name}</NameColumn>\n      <DefaultValueColumn>{defaultValue}</DefaultValueColumn>\n      <DescriptionColumn>{children}</DescriptionColumn>\n      {includeAvailableFrom ? <AvailableFromColumn>{availableFrom}</AvailableFromColumn> : ''}\n    </Row>\n  )\n}\n","import * as React from 'react'\n\nimport Page from '../../../components/Page'\nimport Container from '../../../components/Container'\nimport IndexLayout from '../../../layouts'\nimport { FixedFont, GuideContent, Overview } from '../../../components/guides'\nimport { Example } from '../../../components/api-components'\nimport { Link } from 'gatsby'\n\nconst IndexPage = () => (\n  <IndexLayout>\n    <Page>\n      <Container>\n        <h1>Guide: setting up papupata for servers</h1>\n        <Overview>\n          In order to start implementing APIs on the server you need to configure papupata to let it know about its environment. This guide\n          covers the most common cases and gives pointer for less common ones.\n        </Overview>\n        <GuideContent\n          content={[\n            {\n              heading: 'Prerequisites',\n              anchor: 'prerequisites',\n              content: (\n                <>\n                  <p>\n                    Before starting this guide, should know a little bit about API declarations. See{' '}\n                    <Link to={'/guides/declaring'}>Declaring APIs</Link> for more details.\n                  </p>\n                </>\n              )\n            },\n            {\n              heading: 'The Basics',\n              anchor: 'basics',\n              content: (\n                <>\n                  <p>\n                    The one thing that is absolutely essential for implementing APIs, is providing papupata with either an express\n                    application or router, which it will declare its routes on.\n                  </p>\n                  <p>\n                    The configuration itself takes place using the <FixedFont>configure</FixedFont> method of an API declaration.\n                  </p>\n                  <Example>{`\n                    import express, {Router} from 'express'\n                    const app = express()\n                    const API = new APIDeclaration()\n                    API.configure({\n                      app\n                    })\n                  `}</Example>\n                  <Example>{`\n                    const router = Router()\n                    app.use(router)\n                    API.configure({\n                      router\n                    })\n                  `}</Example>\n                </>\n              )\n            },\n            {\n              heading: 'Automatic route implementation',\n              anchor: 'automatic',\n              content: (\n                <>\n                  <Example>{`\n                  API.configure({\n                    ...API.getConfig(),\n                    autoImplementAllAPIs: true\n                  })\n                  `}</Example>\n                  <p>\n                    If you are going to implement all, or at least the vast majority of the APIs that have been declared using papupata with\n                    papupata, it makes sense to have papupata automatically set up all routes to return 501 Not Implemented until the routes\n                    are actually implemented.\n                  </p>\n                  <p>\n                    This makes it obvious what is wrong if you try to invoke such an API. There is a more important effect to this as well,\n                    as it means that routes are implemented in the order they were declared in, rather than the order they are implemented\n                    in. Usually this does not make a difference, but sometimes the routing can be ambiguous, with the order being the\n                    deciding factor. Consider this example:\n                  </p>\n                  <Example>{`\n                    const api1 = API.declareGetAPI('/entries/all').response<any>()\n                    const api2 = API.declareGetAPI('/entries/:id').params(['id'] as const).response<any>()\n                  `}</Example>\n                  <p>\n                    It's quite obvious reading it that the intent is that /entries/all goes to api1, and, say, /entries/123 goes to api2.\n                    There is however nothing that inherently says that /entries/all shouldn't be handled by api2. Unless the{' '}\n                    <FixedFont>autoImplementAllAPIs</FixedFont> setting is set to true, then you'd have to make sure that implementing api1\n                    takes place before api2 is implemented. With the setting set to true though, it is enough for api1 to be declared before\n                    api2, as is the case in the example.\n                  </p>\n                  <p>\n                    With this setting enabled it is still possible for individual routes to fall back to regular express routing, allowing\n                    the implementation to be done in other ways. This is done by having the implementation or a middleware leading to it\n                    return <FixedFont>papupata.skipHandlingRoute</FixedFont>\n                  </p>\n                  <Example>{`\n                    import {skipHandlingRoute} from 'papupata'\n                    api1.implement(() => skipHandlingRoute)\n                  `}</Example>\n                </>\n              )\n            },\n            {\n              heading: 'Base URL',\n              anchor: 'baseURL',\n              content: (\n                <>\n                  <Example>{`\n                  API.configure({\n                    ...API.getConfig(),\n                    baseURL: 'https://www.example.com'\n                  })\n                  `}</Example>\n                  <p>\n                    Setting up the base url is essential for clients, but it can be useful for servers as well. With a base url set up, you\n                    can call the <FixedFont>getURL</FixedFont> method on the declarations, which can be useful for redirections, callback\n                    urls etc.\n                  </p>\n                  <p>Just for the purpose of implementing routes it is unnecessary.</p>\n                </>\n              )\n            },\n            {\n              heading: 'Non-root routers',\n              anchor: 'nonroot',\n              content: (\n                <>\n                  <Example>{`\n                  API.configure({\n                    ...API.getConfig(),\n                    routerAt: '/api'\n                  })\n                  `}</Example>\n                  <p>\n                    You might find it convenient to set up papupata implementation on an express router that is not at the root of the\n                    server. As a common example, you might want to set up the router to be under /api so that its middleware is only applied\n                    to API calls.\n                  </p>\n                  <p>\n                    This is a supported scenario -- all you have to do is add the <FixedFont>routerAt</FixedFont> option to the\n                    configuration to tell papupata where the router is mounted at.\n                  </p>\n                  <p>\n                    All of the APIs in the declaration to be within the router path -- you cannot have routes at paths where they cannot be\n                    implemented\n                  </p>\n                  <Example>{`\n                  import express, {Router} from 'express'\n                  import {APIDeclaration} from 'papupata'\n\n                  const API = new APIDeclaration()\n                  const getOne = API.declareGetAPI('/api/getOne').response<any>()\n                  const app = express()\n                  const router = Router()\n                  router.use(authenticationMiddleware)\n                  app.use('/api', router)\n\n                  API.configure({\n                    router,\n                    routerAt: '/api'\n                  })\n                  `}</Example>\n                </>\n              )\n            },\n            {\n              heading: 'Middleware',\n              anchor: 'middleware',\n              content: (\n                <>\n                  <Example>{`\n                  API.configure({\n                    ...API.getConfig(),\n                    inherentMiddleware: [myMiddleware1, myMiddleware2]\n                  })\n                  `}</Example>\n                  <p>\n                    Papupata supports middleware, which can be used on the server to process both requests and responses. For more details\n                    see <Link to=\"/guides/server/middleware\">the middleware guide</Link>.\n                  </p>\n                  <p>\n                    Papupata comes with one built-in middleware that changes how undefined responses are handled. Currently an\n                    implementation returning undefined is taken as an indication that it takes full responsibility for handling the\n                    response.\n                  </p>\n                  <p>\n                    In practice though, a more likely scenario is that the API has nothing to return, and having returning undefined result\n                    in HTTP 204 (no content) would be better. And that is exactly what the middleware does.\n                  </p>\n                  <p>Here's an overview of what it actually does:</p>\n                  <ul>\n                    <li>\n                      If headers have already been sent, it does nothing (this still lets you have APIs that take care of the whole response\n                      on their own)\n                    </li>\n                    <li>If status was not explicitly set, it sets it to 204</li>\n                    <li>It sends a response to the client with no data</li>\n                  </ul>\n                  <Example>{`\n                    import {handleUndefinedResponsesMiddleware} from 'papupata'\n                    API.configure({\n                      ...API.getConfig(),\n                      inherentMiddleware: [handleUndefinedResponsesMiddleware]\n                    })\n\n                    api1.implement(() => {}) // results in a 204 response\n                    api2.implement((_req, res) => {res.redirect('/')}) // the redirection works as expected\n                    api3.implement((_req, res) => {res.status(400)}) // status 400, response is sent with no data\n                    api4.implement((_req, res) => {res.send('done')}) // nothing special happens\n                  `}</Example>\n                </>\n              )\n            },\n            {\n              heading: 'Conclusion',\n              anchor: 'conclusion',\n              content: (\n                <>\n                  <p>Now that papupata is set up to respond to requests, the next step should be actually implementing the APIs.</p>\n                  <p>\n                    See <Link to=\"/guides/server/implementing\">implementing APIs</Link> for how to do exactly that.\n                  </p>\n                  <p>\n                    If you are concerned with how papupata interacts with your existing express APIs and middleware, you could also take a\n                    look at <Link to=\"/guides/server/interactingWithExpress\">Interacting with express</Link>.\n                  </p>\n                </>\n              )\n            }\n          ]}\n        />\n      </Container>\n    </Page>\n  </IndexLayout>\n)\n\nexport default IndexPage\n","import React, { ReactNode } from 'react'\nimport { Section, SectionHeading } from './api-components'\nimport styled from 'styled-components'\n\nexport function Overview({ children }: { children: ReactNode }) {\n  return (\n    <Section>\n      <SectionHeading>Overview</SectionHeading>\n      {children}\n    </Section>\n  )\n}\n\ninterface GuidePart {\n  heading: ReactNode\n  anchor: string\n  content: ReactNode\n  level?: number\n}\n\nconst Level0 = styled.h4``\nconst Level1 = styled.h5`\n  font-size: 1.1em;\n`\n\nexport function GuideContent({ content }: { content: GuidePart[] }) {\n  return (\n    <div>\n      <Section>\n        <SectionHeading>Table of contents</SectionHeading>\n        <ul>\n          {content.map((child) => (\n            <li style={{ marginLeft: 18 * (child.level || 0) }} key={child.anchor}>\n              <a href={`#${child.anchor}`}>{child.heading}</a>\n            </li>\n          ))}\n        </ul>\n      </Section>\n      {content.map((child) => {\n        const Heading = !child.level ? Level0 : Level1\n        return (\n          <Section id={child.anchor} key={child.anchor}>\n            <Heading>{child.heading}</Heading>\n            {child.content}\n          </Section>\n        )\n      })}\n    </div>\n  )\n}\n\nexport const FixedFont = styled.span`\n  font-family: 'Consolas', 'Bitstream Vera Sans Mono', 'Courier New', Courier, monospace;\n`\n"],"sourceRoot":""}