(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{492:function(e,t,n){"use strict";n.r(t);var a=n(1),o=n(435),l=n(130),s=n(436),r=n(504),i=n(434),c=n(5),u=n(48),d=n(0);function h(){var e=function(e,t){t||(t=e.slice(0));return e.raw=t,e}(["\n  border-left: 3px solid #eee;\n  padding-left: 30px;\n  margin-bottom: 30px;\n"]);return h=function(){return e},e}var p=c.a.div(h());t.default=function(){return Object(d.d)(s.a,null,Object(d.d)(o.a,null,Object(d.d)(l.a,null,Object(d.d)("h1",null,"Guide: declaring APIs"),Object(d.d)(r.c,null,"Papupata is all about implementing and invoking APIs. In order for any of that to happen, the APIs must first be declared, or modeled using the tools provided by papupata. This guide covers how the declarations are made."),Object(d.d)(r.b,{content:[{heading:"Setting up an API declaration",anchor:"setup",content:Object(d.d)(a.Fragment,null,Object(d.d)("p",null,"The first thing you'll need is an API declaration. Simply put, it typically represents a set of APIs accessible from a single host. It could be all of the APIs of an application, or just one of them."),Object(d.d)("p",null,"In order to actually use the declared APIs, it is necessary to set up configuration, but just for the purposes of declaring APIs we do not have to worry about that."),Object(d.d)(i.c,null,"\n              import {APIDeclaration} from 'papupata'\n              const API = new APIDeclaration()\n              "),Object(d.d)("p",null,"All of the examples in the sections below will expect this API declaration to exist in their scope."))},{heading:"Your first declaration",anchor:"first",content:Object(d.d)(a.Fragment,null,Object(d.d)("p",null,"Let's start with a really simple API. An API found at ",Object(d.d)(r.a,null,"/hello"),", invoked with the HTTP method"," ",Object(d.d)(r.a,null,"GET"),", which a string as its response."),Object(d.d)(i.c,null,"\n                    const helloAPI = API\n                      .declareGetAPI('/hello')\n                      .response<string>()\n                  "),Object(d.d)("p",null,"Seems simple, enough, right? We specify the method and the path by invoking the ",Object(d.d)(r.a,null,"declareGetAPI")," ","function on the API declaration, and then we declare the response type with the ",Object(d.d)(r.a,null,"response")," method."),Object(d.d)("p",null,"Bodies and responses are often complicated objects, and as such they are represented using typescript types. As we see in the example, the type of the response is passed to the ",Object(d.d)(r.a,null,"response")," function as an explicit type parameter."))},{heading:"The anatomy of a declaration",anchor:"anatomy",content:Object(d.d)(a.Fragment,null,Object(d.d)("p",null,"API declarations often contain many things, and many of those can be modeled using papupata."),Object(d.d)("p",null,"Let's start by looking at an API declaration which utilizes all of the possibilities provided by papupata"),Object(d.d)(i.c,null,"\n                const complexAPI = API.declarePostAPI('/update/:id', routeOptions)\n                  .params(['id'] as const)\n                  .query(['author'] as const)\n                  .optionalQuery(['timestamp'] as const)\n                  .queryBool(['notifyWatchers'] as const)\n                  .body<string, Date>()\n                  .response<string, Date>()\n                "),Object(d.d)("p",null,"Having easy-to-read API declarations was one of the main goals of papupata, and hopefully we've been reasonably successful. It is rare to see everything present in the example in real APIs, so it is something of an abomination."),Object(d.d)("p",null,"Anyway, let's briefly go through each part"),Object(d.d)(p,null,Object(d.d)(i.c,null,"const complexAPI"),Object(d.d)("p",null,"You need to store APIs somewhere. Although you declare them on the API declaration object, you can not access them from there -- and you'd never be able to get the type safety if you could."),Object(d.d)("p",null,"For simple cases you can store the APIs in simple variables, but if you are modeling a collection of APIs, it probably makes sense to store the APIs in an object:"),Object(d.d)(i.c,null,"\n                      const apis = {\n                        getOne: API.declareGetAPI(...),\n                        updateOne: API.declareGetAPI(...),\n                        deleteOne: API.declareGetAPI(...),\n                        find: API.declareGetAPI(...),\n                      }\n                    "),Object(d.d)("p",null,"You can even nest objects to make a logical hierarchy out of them.")),Object(d.d)(p,null,Object(d.d)(i.c,null,".declarePostAPI("),Object(d.d)("p",null,"All APIs are declared using one of the methods on an API declaration instance. The naming pattern is always the same, so you can expect to find declareGetAPI, declarePutAPI and so on to be available."),Object(d.d)("p",null,"At this time there is no way to define an API to support multiple methods -- you have do declare it separately for each method.")),Object(d.d)(p,null,Object(d.d)(i.c,null,"'/update/:id'"),Object(d.d)("p",null,"All APIs are declared using relative paths. The base URL is set up before calls can be made, and it can even include paths as well."),Object(d.d)("p",null,"Path parameters must be present in the url passed to the declaration function; they are indicated by a colon before the parameter name."),Object(d.d)("p",null,"Query parameters are NOT included in the url, however.")),Object(d.d)(p,null,Object(d.d)(i.c,null,", routeOptions)"),Object(d.d)("p",null,"Sometimes you need to add metadata to the routes. It could be relevant for the client, server, or both."),Object(d.d)("p",null,"The API declaration has a number of type parameters, one of which is used to define the type of the route options."),Object(d.d)("p",null,"These parameters are typically accessed either from the middleware or the function that actually makes HTTP requests."),Object(d.d)("p",null,"A common use case would be to indicate the need for authentication. This allows the server to verify authentication as needed, while the client can skip obtaining the credentials."),Object(d.d)("p",null,"As the example API declaration does not include options, here is another small example:"),Object(d.d)(i.c,null,"\n                      import {Request} from 'express'\n                      const API = new APIDeclaration<Request, {requiresAuthentication: boolean}>\n                      const api = API.declareGetAPI('/', {requiresAuthentication: false})\n                    ")),Object(d.d)(p,null,Object(d.d)(i.c,null,".params(['id'] as const)"),Object(d.d)("p",null,"In addition to being declared in the URL, path parameters need to be declared in a way that lets typescript know they exist. This call to params serves that purpose."),Object(d.d)("p",null,"Just add all the parameters into an array (omitting the leading colon used in the URL), and add"," ",Object(d.d)(r.a,null,"as const")," after the array."),Object(d.d)("p",null,"At this time path parameters cannot be optional; if you need to support that case, you have to declare multiple APIs that match the different cases."),Object(d.d)("p",null,"Knowing or understanging ",Object(d.d)(r.a,null,"as const")," is not necessary to use papupata, but in case you are interested, causes the array not to be just an array of strings. In the example case, it is a tuple where the first element is ",Object(d.d)(r.a,null,"id"),". From this it is possible to extract the type needed both for implementing and calling the API.")),Object(d.d)(p,null,Object(d.d)(i.c,null,"\n                    .query(['author'] as const)\n                    .optionalQuery(['timestamp'] as const)\n                    .queryBool(['notifyWatchers'] as const)\n                    "),Object(d.d)("p",null,"The format for entering query parameters is the same as with path parameters. There are, however, 3 different types of query parameters; normal, optional and boolean."),Object(d.d)("p",null,"You can have any combination of the 3 in any given API, but they must always be declared in that order."),Object(d.d)("p",null,Object(d.d)(r.a,null,"query")," and ",Object(d.d)(r.a,null,"optionalQuery")," should hopefully be obvious,"," ",Object(d.d)(r.a,null,"queryBool")," is a convenience option; when calling it expects a boolean value instead of a string. On the implementation side, the value ",Object(d.d)(r.a,null,"true")," becomes the boolean true, any other value becomes false.")),Object(d.d)(p,null,Object(d.d)(i.c,null,".body<string, Date>()"),Object(d.d)("p",null,"Oh boy. Let's start with something a little simpler: ",Object(d.d)(r.a,null,".body<string>()"),". That is what you'll usually see, and should be quite straightforward. The body for the request must be a string."),Object(d.d)("p",null,"I can be any type, but in practice the transport medium (commonly json) does tend to put limitations to what can really be transferred. Functions, for example, you probably can't just pass along over APIs."),Object(d.d)("p",null,"Sometimes there are types which are transformed automatically. When using JSON, dates for example are commonly just stored as a string, even if you original payload had it as a date. This creates a typing conundrum: surely you should be able to pass in a date, even if the other side will see it as a string. This is where the second type parameter comes in. The first parameter is the type of the body, as it will be seen by the server, and the second one is the type of the body the way the client application can pass it. The conversion between the two should be transparent to the user. If you only pass one type parameter, it is used for both cases.")),Object(d.d)(p,null,Object(d.d)(i.c,null,".response<string, Date>()"),Object(d.d)("p",null,"Response work just like body does, except from the opposite point of view."),Object(d.d)("p",null,"You can pass a single type argument and it'll be the type of there response everywhere. If you pass another one though, that is what the implementation is expected to return. Again, the conversion to the type seen by the client should be implicit, either built into the serialization process or maybe in the form of a middleware."),Object(d.d)("p",null,"All declarations must end with a response. The type can be void or undefined if the API returns nothing, but the call to ",Object(d.d)(r.a,null,"response")," must be there regardless.")))},{heading:"Error handling",anchor:"errors",content:Object(d.d)(a.Fragment,null,Object(d.d)("p",null,"At this time papupata does not have particular support for managing errors."),Object(d.d)("p",null,"You could type the response to be either the actual response or an error response, but that's essentially the extent of it."),Object(d.d)(i.c,null,"\n                const api = API.declareGetAPI('/path')\n                  .response<Data | {errorMessage: string}>()\n                "),Object(d.d)("p",null,"Even so, there are certainly limitations to this. If the client request library rejects the failed requests, the type information will be lost anyway and even in success cases you have to ensure you got the data object even if it should be obvious."),Object(d.d)("p",null,"This is certainly something that will be developed further in upcoming releases."))},{heading:"Conclusion",anchor:"conclusion",content:Object(d.d)(a.Fragment,null,Object(d.d)("p",null,"What we've covered includes essentially everything papupata has for declaring the APIs."),Object(d.d)("p",null,"The logical next steps would be about how to actually use the declarations. If you want to call the declared APIs, head on over to ",Object(d.d)(u.a,{to:"/guides/client/setup"},"setting up papupata client"),", or perhaps straight to"," ",Object(d.d)(u.a,{to:"/guides/client/calling"},"calling APIs")," if someone else has set things up for you already."),Object(d.d)("p",null,"On the other hand, if you want to implement APIs that have been declared,"," ",Object(d.d)(u.a,{to:"/guides/server/setup"},"setting up papupata server")," and"," ",Object(d.d)(u.a,{to:"/guides/server/implementing"},"implementing APIs")," are good next guides."),Object(d.d)("p",null,"Lastly, if you want to know about how to extract metadata from the declared APIs, there is a guide about"," ",Object(d.d)(u.a,{to:"/guides/metadata"},"metadata"),", too."))}]}))))}},504:function(e,t,n){"use strict";n.d(t,"c",(function(){return u})),n.d(t,"b",(function(){return p})),n.d(t,"a",(function(){return b}));n(505),n(1);var a=n(434),o=n(5),l=n(0);function s(){var e=c(['\n  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace\n']);return s=function(){return e},e}function r(){var e=c(["\n  font-size: 1.1em;\n"]);return r=function(){return e},e}function i(){var e=c([""]);return i=function(){return e},e}function c(e,t){return t||(t=e.slice(0)),e.raw=t,e}function u(e){var t=e.children;return Object(l.d)(a.j,null,Object(l.d)(a.k,null,"Overview"),t)}var d=o.a.h4(i()),h=o.a.h5(r());function p(e){var t=e.content;return Object(l.d)("div",null,Object(l.d)(a.j,null,Object(l.d)(a.k,null,"Table of contents"),Object(l.d)("ul",null,t.map((function(e){return Object(l.d)("li",{style:{marginLeft:18*(e.level||0)},key:e.anchor},Object(l.d)("a",{href:"#"+e.anchor},e.heading))})))),t.map((function(e){var t=e.level?h:d;return Object(l.d)(a.j,{id:e.anchor,key:e.anchor},Object(l.d)(t,null,e.heading),e.content)})))}var b=o.a.span(s())},505:function(e,t,n){"use strict";n(103)("anchor",(function(e){return function(t){return e(this,"a","name",t)}}))}}]);
//# sourceMappingURL=component---src-pages-guides-declaring-tsx-49ca9a8fae971c1eb5d1.js.map