{"version":3,"sources":["webpack://papupata-docs/./src/components/IncludeAvailableFromContext.tsx","webpack://papupata-docs/./src/components/VersionVariants.tsx","webpack://papupata-docs/./src/components/api-components.tsx","webpack://papupata-docs/./src/components/guides.tsx","webpack://papupata-docs/./src/pages/guides/declaring/query-based-variants.tsx"],"names":["IncludeAvailableFromContext","React","Container","styled","Note","VersionVariants","variants","isRecommendation","useState","selectedVersion","setSelectedVersion","updateSelectedVersion","useCallback","e","target","value","onChange","Object","keys","filter","variant","version","isApplicable","map","key","Section","SectionHeading","SubHeading","ExampleCommonContainer","Purpose","children","AvailableFrom","Usage","Parameters","includeAvailableFrom","label","Parameter","name","dataType","availableFrom","MethodReturnType","Caveats","Examples","Example","language","ExampleCommon","TypeParameters","Row","NameColumn","DefaultValueColumn","DescriptionColumn","AvailableFromColumn","TypeParameter","defaultValue","Overview","Level0","Level1","GuideContent","content","child","style","marginLeft","level","anchor","href","heading","Heading","id","FixedFont","LineIndent","GotchaExample","routing","join","to"],"mappings":"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","file":"component---src-pages-guides-declaring-query-based-variants-tsx-d341c3e7b2793c80b8c6.js","sourcesContent":["import * as React from 'react'\n\nexport const IncludeAvailableFromContext = React.createContext(false)\n","import React, { ReactNode, useCallback, useState } from 'react'\nimport styled from 'styled-components'\n\nexport type VariantVersion = '*' | SelectableVersion\ntype SelectableVersion = '1.x' | '2.x'\n\ninterface Props {\n  isRecommendation?: boolean\n  variants: {\n    [K in VariantVersion]?: ReactNode\n  }\n}\n\nconst Container = styled.div`\n  border-left: 4px solid #663399;\n  padding: 5px 0 5px 10px;\n`\n\nconst Note = styled.div`\n  display: inline-block;\n  margin-left: 10px;\n  font-size: 0.9em;\n`\n\nexport default function VersionVariants({ variants, isRecommendation }: Props) {\n  const [selectedVersion, setSelectedVersion] = useState<SelectableVersion>('2.x')\n  const updateSelectedVersion = useCallback((e: React.ChangeEvent<HTMLSelectElement>) => {\n    setSelectedVersion(e.target.value as any)\n  }, [])\n\n  return (\n    <Container>\n      <select value={selectedVersion} onChange={updateSelectedVersion}>\n        <option value=\"1.x\">Papupata 1.x</option>\n        <option value=\"2.x\">Papupata 2.x</option>\n      </select>\n      {isRecommendation && <Note>Older styles are still supported in later versions, just not preferred.</Note>}\n      {(Object.keys(variants) as VariantVersion[])\n        .filter((variant) => isApplicable(selectedVersion, variant))\n        .map((variant) => (\n          <div key={variant}>{variants[variant]}</div>\n        ))}\n    </Container>\n  )\n}\n\nfunction isApplicable(version: SelectableVersion, variant: VariantVersion) {\n  if (variant === '*') return true\n  return variant === version\n}\n","import styled from 'styled-components'\nimport React, { ReactNode } from 'react'\nimport { Code } from './Code'\nimport { IncludeAvailableFromContext } from './IncludeAvailableFromContext'\n\nexport const Section = styled.section``\nexport const SectionHeading = styled.h4``\nexport const SubHeading = styled.h5``\nexport const ExampleCommonContainer = styled.section`\n  padding: 15px 30px;\n  background: lightyellow;\n`\n\nexport const Purpose: React.FC = ({ children }) => (\n    <Section>\n      <SectionHeading>Purpose</SectionHeading>\n      {children}\n    </Section>\n  )\n\nexport type ValidVersions = '1.1.0' | '1.2.0' | '1.5.0' | '1.8.0' | '2.0.0'\nexport const AvailableFrom = ({ version }: { version: ValidVersions }) => (\n    <Section>\n      <SectionHeading>Availability</SectionHeading>\n      This functionality is available from papupata version {version} onwards.\n    </Section>\n  )\n\nexport const Usage: React.FC = ({ children }) => (\n    <Section>\n      <SectionHeading>Usage</SectionHeading>\n      {children}\n    </Section>\n  )\nexport const Parameters: React.FC<{ includeAvailableFrom?: boolean; label?: string }> = ({ children, includeAvailableFrom, label }) => (\n    <Section>\n      <IncludeAvailableFromContext.Provider value={!!includeAvailableFrom}>\n        <SectionHeading>Parameters{label && `: ${label}`}</SectionHeading>\n        {children ? (\n          <table>\n            <thead>\n              <tr>\n                <th>Name</th>\n                <th>Type</th>\n                <th>Description</th>\n                {includeAvailableFrom && <th>Introduced in</th>}\n              </tr>\n            </thead>\n            <tbody>{children}</tbody>\n          </table>\n        ) : (\n          <p>There are no parameters.</p>\n        )}\n      </IncludeAvailableFromContext.Provider>\n    </Section>\n  )\n\nexport const Parameter: React.FC<{ name: string; dataType: any; availableFrom?: ValidVersions }> = ({\n  children,\n  name,\n  dataType,\n  availableFrom = '1.0.0'\n}) => {\n  const includeAvailableFrom = React.useContext(IncludeAvailableFromContext)\n  return (\n    <tr>\n      <td>{name}</td>\n      <td>{dataType}</td>\n      <td>{children}</td>\n      {includeAvailableFrom && <td>{availableFrom}</td>}\n    </tr>\n  )\n}\n\nexport const MethodReturnType: React.FC = ({ children }) => (\n    <Section>\n      <SectionHeading>Returns</SectionHeading>\n      {children}\n    </Section>\n  )\n\nexport const Caveats: React.FC = ({ children }) => (\n    <Section>\n      <SectionHeading>Caveats</SectionHeading>\n      {children}\n    </Section>\n  )\nexport const Examples: React.FC<{ children: any }> = ({ children }) => (\n    <Section>\n      <SectionHeading>Examples</SectionHeading>\n      {children}\n    </Section>\n  )\n\nexport const Example: React.FC<{ label?: string; children: string }> = ({ children, label }) => (\n    <>\n      {label && <SubHeading>{label}</SubHeading>}\n      <Code language={'typescript'}>{children}</Code>\n    </>\n  )\n\nexport const ExampleCommon: React.FC<{ children: any }> = ({ children }) => (\n    <ExampleCommonContainer>\n      <SubHeading>Common to examples below:</SubHeading>\n      {children}\n    </ExampleCommonContainer>\n  )\n\nexport const TypeParameters: React.FC<{ children: ReactNode; includeAvailableFrom?: boolean }> = ({ children, includeAvailableFrom }) => (\n    <Section>\n      <SectionHeading>Type parameeters</SectionHeading>\n      <IncludeAvailableFromContext.Provider value={!!includeAvailableFrom}>\n        <SectionHeading>Parameters</SectionHeading>\n        {children ? (\n          <table>\n            <thead>\n              <tr>\n                <th>Name</th>\n                <th>Default value</th>\n                <th>Description</th>\n                {includeAvailableFrom ? <th>Introduced in</th> : ''}\n              </tr>\n            </thead>\n            <tbody>{children}</tbody>\n          </table>\n        ) : (\n          <p>There are no parameters.</p>\n        )}\n      </IncludeAvailableFromContext.Provider>\n    </Section>\n  )\n\nconst Row = styled.tr``\nconst NameColumn = styled.td``\nconst DefaultValueColumn = styled.td``\nconst DescriptionColumn = styled.td``\nconst AvailableFromColumn = styled.td``\n\nexport const TypeParameter: React.FC<{ name: string; defaultValue?: string; availableFrom?: string }> = ({\n  children,\n  name,\n  defaultValue,\n  availableFrom = 'none'\n}) => {\n  const includeAvailableFrom = React.useContext(IncludeAvailableFromContext)\n  return (\n    <Row>\n      <NameColumn>{name}</NameColumn>\n      <DefaultValueColumn>{defaultValue}</DefaultValueColumn>\n      <DescriptionColumn>{children}</DescriptionColumn>\n      {includeAvailableFrom ? <AvailableFromColumn>{availableFrom}</AvailableFromColumn> : ''}\n    </Row>\n  )\n}\n","import React, { ReactNode } from 'react'\nimport { Section, SectionHeading } from './api-components'\nimport styled from 'styled-components'\n\nexport function Overview({ children }: { children: ReactNode }) {\n  return (\n    <Section>\n      <SectionHeading>Overview</SectionHeading>\n      {children}\n    </Section>\n  )\n}\n\ninterface GuidePart {\n  heading: ReactNode\n  anchor: string\n  content: ReactNode\n  level?: number\n}\n\nconst Level0 = styled.h4``\nconst Level1 = styled.h5`\n  font-size: 1.1em;\n`\n\nexport function GuideContent({ content }: { content: GuidePart[] }) {\n  return (\n    <div>\n      <Section>\n        <SectionHeading>Table of contents</SectionHeading>\n        <ul>\n          {content.map((child) => (\n            <li style={{ marginLeft: 18 * (child.level || 0) }} key={child.anchor}>\n              <a href={`#${child.anchor}`}>{child.heading}</a>\n            </li>\n          ))}\n        </ul>\n      </Section>\n      {content.map((child) => {\n        const Heading = !child.level ? Level0 : Level1\n        return (\n          <Section id={child.anchor} key={child.anchor}>\n            <Heading>{child.heading}</Heading>\n            {child.content}\n          </Section>\n        )\n      })}\n    </div>\n  )\n}\n\nexport const FixedFont = styled.span`\n  font-family: 'Consolas', 'Bitstream Vera Sans Mono', 'Courier New', Courier, monospace;\n`\n","import '../../../prepare'\nimport * as React from 'react'\n\nimport Page from '../../../components/Page'\nimport Container from '../../../components/Container'\nimport IndexLayout from '../../../layouts'\nimport { FixedFont, GuideContent, Overview } from '../../../components/guides'\nimport { AvailableFrom, Example } from '../../../components/api-components'\nimport styled from 'styled-components'\nimport { Link } from 'gatsby'\nimport VersionVariants from '../../../components/VersionVariants'\n\nconst LineIndent = styled.div`\n  border-left: 3px solid #eee;\n  padding-left: 30px;\n  margin-bottom: 30px;\n`\n\ninterface GEProps {\n  label: string\n  variants: string[]\n}\n\nconst GotchaExample = ({ label, variants }: GEProps) => (\n    <LineIndent>\n      <p>{label}</p>\n      <Example>{variants.map((routing) => `API.declareGetAPI('/api?${routing}')`).join('\\n')}</Example>\n    </LineIndent>\n  )\n\nconst QBVPage = () => (\n  <IndexLayout>\n    <Page>\n      <Container>\n        <h1>Guide: Query-based variants</h1>\n        <Overview>\n          Sometimes you have APIs that only differ from each other based on their query parameters. For example, the response could be of a\n          different type based on value of one. Papupata offers a way to deal with this.\n        </Overview>\n        <AvailableFrom version={'1.8.0'} />\n        <GuideContent\n          content={[\n            {\n              heading: 'Prerequisites',\n              anchor: 'prerequisites',\n              content: (\n                <>\n                  <p>\n                    Before starting this guide, you need to have an API declaration, with declared APIs. For information on how to get\n                    there, see <Link to={'/guides/declaring'}>Declaring APIs</Link>.\n                  </p>\n                  <p>For the examples in the guide, the following code is assumed to be present in the scope:</p>\n                  <Example>{`\n                    import { APIDeclaration } from 'papupata'\n                    const API = new APIDeclaration()\n                  `}</Example>\n                </>\n              )\n            },\n            {\n              heading: 'The Basics',\n              anchor: 'basics',\n              content: (\n                <>\n                  <p>\n                    Query parameter based API selection is embedded into the path portion of an API declaration. This is because it, like\n                    everything else in the path, affects the routing that connects the request to the correct handler.\n                  </p>\n                  <p>\n                    The query parameter routing information is presented in a fashion not unlike regular query parameters, but there are\n                    extensions to the syntax.\n                  </p>\n                  <Example>\n                    {`\n                    const api = API.declareGetAPI('/myAPI?variant=orange').response<void>()\n                    `}\n                  </Example>\n                  <p>\n                    There can be any number of query parameter based constraints on an API, even multiple ones for the same parameter when\n                    it makes sense.\n                  </p>\n                  <Example>\n                    {`\n                    const api = API.declareGetAPI('/myAPI?variant=orange&travel=underwater&liquid=water').response<void>()\n                    `}\n                  </Example>\n                </>\n              )\n            },\n            {\n              heading: 'The Specifics',\n              anchor: 'specifics',\n              content: <></>\n            },\n            {\n              heading: 'Specific (hard-coded) values',\n              anchor: 'hardcoded',\n              level: 2,\n              content: (\n                <>\n                  <p>Requiring a query parameter to have a specific value is done with the regular query string syntax, such as</p>\n                  <Example>\n                    {`\n                    const api = API.declareGetAPI('/myAPI?variant=orange').response<void>()\n                    `}\n                  </Example>\n                  <p>\n                    requires all invocations of the API to have the query parameter <FixedFont>variant</FixedFont> set to{' '}\n                    <FixedFont>orange</FixedFont>. When using papupata to call the API, it automatically sets up the variable, and in fact\n                    you generally speaking cannot set it manually. That is, making the call:\n                  </p>\n                  <Example>\n                    {`\n                    await api()\n                    `}\n                  </Example>\n                  <p>\n                    You are not expected to include <FixedFont>{`{variant: 'orange'}`}</FixedFont> in the call, although it will be included\n                    in the actual REST call.\n                  </p>\n                  <p>\n                    On the server, according to type information that parameter is not available, but it is in fact there in case, say, a\n                    middleware needs access to it. If you <strong>really</strong> need it in the types, you can add the parameter into the{' '}\n                    <FixedFont>optionalQuery</FixedFont> portion of the declaration, even though it is not actually optional. This is done\n                    to ensure that the invocation does not require the user to enter it.\n                  </p>\n                  <p>\n                    You can have multiple possible values for the parameter. Of course the parameter cannot be all of them at once (as\n                    arrays are not supported), so this just means that any of the values will do. Note that this creates an{' '}\n                    <a href=\"#ambiguous\">ambiguous call</a>.\n                  </p>\n                  <Example>\n                    {`\n                    const api = API.declareGetAPI('/myAPI?variant=orange&variant=red&variant=yellow').response<void>()\n                    `}\n                  </Example>\n                </>\n              )\n            },\n            {\n              heading: 'Non-matching value',\n              anchor: 'non-matching',\n              level: 2,\n              content: (\n                <>\n                  <p>\n                    You can have an API that only applies when a parameter has a value that is not one of the ones you've specified. Instead\n                    of the usual name=value notation, you instead use value!=value.\n                  </p>\n                  <VersionVariants\n                    isRecommendation\n                    variants={{\n                      '1.x': (\n                        <Example>\n                          {`\n                            const api = API.declareGetAPI('/myAPI?variant!=orange')\n                              .query(['variant'] as const)\n                              .response<void>()\n                            `}\n                        </Example>\n                      ),\n                      '2.x': (\n                        <Example>\n                          {`\n                            const api = API.declareGetAPI('/myAPI?variant!=orange')\n                              .query({variant: String})\n                              .response<void>()\n                            `}\n                        </Example>\n                      )\n                    }}\n                  />\n                  <p>\n                    requires all invocations of the API to have the query parameter <FixedFont>variant</FixedFont> not to be set to{' '}\n                    <FixedFont>orange</FixedFont>\n                  </p>\n                  <Example>\n                    {`\n                    await api({variant: 'purple'})\n                    `}\n                  </Example>\n                  <p>\n                    If you attempt to supply one of the forbidden values for a client invocation, it will throw an exception. On the server,\n                    this is just a regular query parameter.\n                  </p>\n                  <p>Do note that the lack of a value is considered to pass this check, so the following is fine as well:</p>\n                  <Example>\n                    {`\n                    const api = API.declareGetAPI('/myAPI?variant!=orange').response<void>()\n                    await api()\n                    `}\n                  </Example>\n                  <p>\n                    While it is a bit odd, this way the non-matching value is the exact opposite of the specific value routing, covering all\n                    cases. If you specifically want there to be a value which is not one of the ones you've provided, you can combine this\n                    with \"any value\" routing rule.\n                  </p>{' '}\n                  <VersionVariants\n                    isRecommendation\n                    variants={{\n                      '1.x': (\n                        <Example>\n                          {`\n                            const api = API.declareGetAPI('/myAPI?variant!=orange&variant')\n                              .query(['variant'] as const)\n                              .response<void>()\n                            `}\n                        </Example>\n                      ),\n                      '2.x': (\n                        <Example>\n                          {`\n                            const api = API.declareGetAPI('/myAPI?variant!=orange&variant')\n                              .query({variant: String})\n                              .response<void>()\n                            `}\n                        </Example>\n                      )\n                    }}\n                  />\n                </>\n              )\n            },\n            {\n              heading: 'Lack of query parameter',\n              anchor: 'lacking',\n              level: 2,\n              content: (\n                <>\n                  <p>\n                    You can indicate that the API variant is only to be called when a query parameter is not present by prepending an\n                    exclamation mark to the name of the parameter.\n                  </p>\n                  <Example>\n                    {`\n                    const api = API.declareGetAPI('/myAPI?!variant')\n                      .response<void>()\n                    `}\n                  </Example>\n                  <p>\n                    Do note that an empty value (calling the REST API with something like <FixedFont>/myAPI?variant=</FixedFont> or{' '}\n                    <FixedFont>/myAPI?variant</FixedFont>) <strong>is</strong> considered to be a call with the parameter present, and as\n                    such will not match the API as declared. You can declare an API that accepts both by combining it with specific value\n                    routing.\n                  </p>\n                  <Example>\n                    {`\n                    const api = API.declareGetAPI('/myAPI?!variant&variant=')\n                      .response<void>()\n                    `}\n                  </Example>\n                  <p>\n                    This creates an <a href=\"#ambiguous\">ambiguous call</a>.\n                  </p>\n                </>\n              )\n            },\n            {\n              heading: 'Presence of query parameter',\n              anchor: 'presence',\n              level: 2,\n              content: (\n                <>\n                  <p>\n                    You can indicate that the API variant is only to be called when a query parameter is present by simply having its name,\n                    with no equality or value in the query string part.\n                  </p>{' '}\n                  <VersionVariants\n                    isRecommendation\n                    variants={{\n                      '1.x': (\n                        <Example>\n                          {`\n                            const api = API.declareGetAPI('/myAPI?variant')\n                              .query(['variant'] as const)\n                              .response<void>()\n                            `}\n                        </Example>\n                      ),\n                      '2.x': (\n                        <Example>\n                          {`\n                            const api = API.declareGetAPI('/myAPI?variant')\n                              .query({variant: String})\n                              .response<void>()\n                            `}\n                        </Example>\n                      )\n                    }}\n                  />\n                  <p>\n                    Do note that an empty value (calling the REST API with something like <FixedFont>/myAPI?variant=</FixedFont> or{' '}\n                    <FixedFont>/myAPI?variant</FixedFont>) <strong>is</strong> considered to be a call with the parameter present and is\n                    match for this rule. You can specifically exclude empty values by using the non-matching value routing as well.\n                  </p>\n                  <Example>\n                    {`\n                    const api = API.declareGetAPI('/myAPI?variant&variant!=')\n                      .response<void>()\n                    `}\n                  </Example>\n                </>\n              )\n            },\n            {\n              heading: 'Ambiguous calls',\n              anchor: 'ambiguous',\n              content: (\n                <>\n                  <p>\n                    By combining routing rules you can end up in a situation where there are multiple possible values for a query parameter.\n                    In these cases, when invoking the API using papupata, the client is guaranteed to choose valid parameters, but it may\n                    choose any valid combination in a potentially unpredictable fashion.\n                  </p>\n                </>\n              )\n            },\n\n            {\n              heading: 'The big gotcha',\n              anchor: 'gotcha',\n              content: (\n                <>\n                  <p>\n                    Unless you really know what you're doing, having overlapping API declarations is a good way to cause issues for yourself\n                    down the line. That is, overlapping in the sense that as far as routing is concerned, multiple APIs could be valid for a\n                    single call.\n                  </p>\n                  <p>\n                    To avoid doing this when using query-based API variants, instead of going with a default \"anything not handled goes\n                    here\" route, ensure your APIs use negations of the rules of the other routes to allow non-ambiguous routing.\n                  </p>\n                  <p>A few examples:</p>\n                  <GotchaExample label=\"Specific value and non-specific value\" variants={['variant=alpha', 'variant!=alpha']} />\n                  <GotchaExample\n                    label=\"Multiple specific values\"\n                    variants={['variant=alpha', 'variant=beta', 'variant!=alpha&variant!=beta']}\n                  />\n                  <GotchaExample label=\"Presence and non-presence\" variants={['variant', '!variant']} />\n                  <GotchaExample\n                    label=\"Presence of non-empty and non-present/empty\"\n                    variants={['variant&variant!=', '!variant&variant=']}\n                  />\n                  <p>\n                    If this seems impractical because of, say, complexity, you can have overlap as long as you consider its implications,\n                    specifically how routing considers routes:\n                  </p>\n                  <ul>\n                    <li>\n                      if <FixedFont>autoImplementAllAPIs</FixedFont> is set to false (default in papupata 1.x), the variants are checked in\n                      their implementation order\n                    </li>\n                    <li>\n                      if <FixedFont>autoImplementAllAPIs</FixedFont> is set to true (default in papupata 2.x), the variants are checked in\n                      their declaration order\n                    </li>\n                    <li>\n                      If you encounter misrouting (whether in the route implementation or a middleware leading there), you can import{' '}\n                      <FixedFont>skipHandlingRoute</FixedFont>\n                      from papupata and return it to resume routing from later variants.\n                    </li>\n                  </ul>\n                </>\n              )\n            },\n            {\n              heading: 'Use cases',\n              anchor: 'useCases',\n              content: (\n                <>\n                  <p>\n                    Probably the most likely use case are APIs that either accept differents sets of parameters based on other parameters,\n                    or ones that return different data based on the query parameters.\n                  </p>\n                  <p>So let's have an example of an API with different sets of inputs:</p>\n                  <LineIndent>\n                    {' '}\n                    <VersionVariants\n                      isRecommendation\n                      variants={{\n                        '1.x': (\n                          <Example>\n                            {`\n                              const simpleSearch = API.declarePostAPI('/search?advanced!=true')\n                                .query(['queryString'] as const)\n                                .response<any>()\n\n                              const advancedSearch = API.declarePostAPI('/search?advanced=true')\n                                .query(['name', 'address', 'phone', 'email'] as const)\n                                .response<any>()\n                              `}\n                          </Example>\n                        ),\n                        '2.x': (\n                          <Example>\n                            {`\n                              const simpleSearch = API.declarePostAPI('/search?advanced!=true')\n                                .query({queryString: String})\n                                .response<any>()\n\n                              const advancedSearch = API.declarePostAPI('/search?advanced=true')\n                                .query({name: String, address: String, phone: String, email: String}})\n                                .response<any>()\n                              `}\n                          </Example>\n                        )\n                      }}\n                    />\n                    <p>\n                      So basically a single endpoint serves two types of search functionality, but using the query-based API variants we can\n                      have both of them work perfectly in a typed fashion.\n                    </p>\n                  </LineIndent>\n                  <p>And for different responses, perhaps something like this:</p>\n                  <LineIndent>\n                    <Example>\n                      {`\n                    const myDetailsAPI = API.declarePostAPI('/my-details?includeRelations=false')\n                      .response<UserDetails>()\n\n                    const myDetailsWithRelationsAPI = API.declarePostAPI('/my-details?includeRelations=true')\n                      .response<UserDetails & RelationInfo>()\n                    `}\n                    </Example>\n                    <p>Again, a single API and two types of output, fully typed.</p>\n                  </LineIndent>\n                </>\n              )\n            }\n          ]}\n        />\n      </Container>\n    </Page>\n  </IndexLayout>\n)\n\nexport default QBVPage\n"],"sourceRoot":""}