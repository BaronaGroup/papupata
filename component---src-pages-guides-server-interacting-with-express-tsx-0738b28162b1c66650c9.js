(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{495:function(e,t,n){"use strict";n.r(t);var a=n(1),r=n(435),o=n(130),i=n(436),s=n(504),p=n(434),u=n(48),l=n(0);t.default=function(){return Object(l.d)(i.a,null,Object(l.d)(r.a,null,Object(l.d)(o.a,null,Object(l.d)("h1",null,"Guide: interacting with express"),Object(l.d)(s.c,null,"It is not uncommon to want to integrate papupata into an existing express application, whether it is to use the middleware or just using papupata to model the APIs implemented with express."),Object(l.d)(s.b,{content:[{heading:"The basics",anchor:"basics",content:Object(l.d)(a.Fragment,null,Object(l.d)("p",null,"Papupata connects itself straight to the express app, or you can provide it an express router that you can embed anywhere you wish in your express application. The timing of things depends on the configuration setting"," ",Object(l.d)(s.a,null,"autoImplementAllAPIs"),": if it is enabled, the APIs are added to the app or router when the configuration happens, if disabled, they are added when they are implemented."),Object(l.d)("p",null,"Any middleware before and after the attachment point are used as normal -- whether they are on the router or the app."),Object(l.d)("p",null,"Below are examples that hopefully clarify how the different variants work; before and routerBefore are run before the implementation for api, after and routerAfter after."),Object(l.d)("p",null,"App, no autoImplementAllAPIs:"),Object(l.d)(p.c,null,"\n                    const app = express()\n                    API.configure({app})                    \n                    app.use(before)\n                    api.implement(implementation)\n                    app.use(after)\n                  "),Object(l.d)("p",null,"Router, no autoImplementAllAPIs:"),Object(l.d)(p.c,null,"\n                    import express, {Router} from 'express'\n                    const router = Router()\n                    API.configure({router})  \n\n                    router.use(routerBefore)\n                    api.implement(implementation)\n                    router.use(routerAfter)\n\n                    const app = express()\n                    app.use(before)\n                    app.use(router)\n                    app.use(after)\n                  "),Object(l.d)("p",null,"App, using autoImplementAllAPIs:"),Object(l.d)(p.c,null,"\n                    const app = express()\n                    app.use(before)\n                    API.configure({app, autoImplementAllAPIs: true})                    \n                    app.use(after)\n                    api.implement(implementation)                    \n                  "),Object(l.d)("p",null,"Router, using autoImplementAllAPIs:"),Object(l.d)(p.c,null,"\n                    import express, {Router} from 'express'\n                    const router = Router()\n                    \n                    router.use(routerBefore)\n                    API.configure({router, autoImplementAllAPIs: true})  \n                    router.use(routerAfter)\n\n                    const app = express()\n                    app.use(before)\n                    app.use(router)\n                    app.use(after)\n\n                    api.implement(implementation)                    \n                  "))},{heading:"Where on the app should papupata implementation be?",anchor:"where",content:Object(l.d)(a.Fragment,null,Object(l.d)("p",null,"In an app with both papupata and non-papupata routes it should usually be the case that papupata route implementations take place before express routes. This helps ensure that the APIs are implemented according to the API declarations, without a plain express implementation taking over."),Object(l.d)("p",null,"Things aren't always quite that simple though, since ambiguous routing rules and complicated middleware interactions can add difficult dependencies on implementation order. See"," ",Object(l.d)("a",{href:"#declOnly"},"Implementing APIs declared with just express")," for some ideas on what could be done in this case."),Object(l.d)("p",null,"How about timing with middleware? If you have middleware that is common with the rest of you application then it makes sense to just set it all up for all of the routes. Middleware exclusive to papupata routes could be included on its router, or as papupata middleware. The advantage of using papupata middleware is that it is only used whenever an actual papupata API is called, not just for being at a specific path. Express-only middleware you'll probably want to add after the papupata routes so it ends up being bypassed outside of error cases."))},{heading:"Error handling",anchor:"errorHandling",content:Object(l.d)(a.Fragment,null,"Any exceptions thrown in papupata implementations and middleware (unless handled otherwise) are passed as normal to express error handling middleware.",Object(l.d)(p.c,null,"\n                  api.implement(() => { throw new Error('Oops') })\n\n                  app.use(papupataRouter)\n                  app.use((err, req, res, next) => {\n                    res.status(500)\n                    log.error(err)\n                    res.send('An error happened')\n                  })\n                "))},{heading:"Route-specific middleware",anchor:"routeSpecific",content:Object(l.d)(a.Fragment,null,Object(l.d)("p",null,"You can apply route-specific middleware using the ",Object(l.d)(s.a,null,"implementWithExpressMiddleware")," method."),Object(l.d)(p.c,null,"\n                    api.implementWithExpressMiddleware([myExpressMiddleware], implementation)\n                  "),Object(l.d)("p",null,"If you need to combine express middleware with papupata middleware (which can manipulate the response after the route implementation), you can convert express middleware to papupata middleware using the"," ",Object(l.d)(s.a,null,"convertExpressMiddleware")," function."),Object(l.d)(p.c,null,"\n                    import {convertExpressMiddleware} from 'papupata'\n                    api.implementWithExpressMiddleware(\n                      [myPapupataMiddleware, convertExpressMiddleware(myExpressMiddleware)], \n                      implementation\n                    )\n                  "),Object(l.d)("p",null,"See ",Object(l.d)(u.a,{to:"/guides/server/middleware"},"the middleware guide")," for more information"))},{heading:"Implementing APIs declared with just express",anchor:"declonly",content:Object(l.d)(a.Fragment,null,Object(l.d)("p",null,"While much of the benefit to using papupata comes from using it to implement APIs, sometimes with existing applications it can be difficult to convert existing APIs to use it because of complicated middleware or routing considerations."),Object(l.d)("p",null,"In these situations you can still use papupata to declare the API, and then use your old implementation. At its simplest you just implement the API you have declared and that is it. If you want to utilize the typescript types, it is also possible to an extent."),Object(l.d)(p.c,null,"\n                    const api = API.declareGetAPI('/path/:id')\n                      .params(['id'] as const)\n                      .query(['search'] as const)\n                      .body<string>()\n                      .response<string>()\n\n                    app[api.method](api.path, (req, res, next) => {\n                      const typedRequest = req as typeof api.RequestType\n                      const response: typeof api.ResponseType = await calculateResponse()\n                      res.send(response)\n                    })\n                  "),Object(l.d)("p",null,"The main caveat is that boolean query parameters are typed as booleans when they are just strings in express. If this is a problem, you can use a helper type to convert the request to express style using a helper type such as the following:"),Object(l.d)(p.c,null,"\n                    type PapupataToExpressRequest<T> = T extends { query: infer U }\n                      ? Omit<T, 'query'> & { query: { [t in keyof U]: string } }\n                      : T\n                  \n                    type ExpressRequest = PapupataToExpressRequest<typeof api.RequestType>\n                  "),Object(l.d)("p",null,"If you've opted to use the ",Object(l.d)(s.a,null,"autoImplementAllAPIs")," setting, any routes declared in papupata are set up to return HTTP 501 not implemented, assuming you configure papupata to your express application. This of course is undesirable when you actually want papupata to ignore the request. If you want the benefits of the setting anyway, there is a way around it; individual route implementations can return a special token value"," ",Object(l.d)(s.a,null,"papupata.skipHandlingRoute")," to indicate that routing is to continue onwards."),Object(l.d)(p.c,null,"\n                    import {skipHandlingRoute} from 'papupata'\n\n                    api.implement(() => skipHandlingRoute)\n                    app[api.method](api.path, (req, res, next) => {\n                      // this is where calls to api end up\n                    })\n                    "),Object(l.d)("p",null,"Alternatively you could implement your express routes before papupata routes, but that could end up with mismatched API declarations and implementations so doing so is not without issues, either."))}]}))))}},504:function(e,t,n){"use strict";n.d(t,"c",(function(){return l})),n.d(t,"b",(function(){return m})),n.d(t,"a",(function(){return h}));n(505),n(1);var a=n(434),r=n(4),o=n(0);function i(){var e=u(['\n  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace\n']);return i=function(){return e},e}function s(){var e=u(["\n  font-size: 1.1em;\n"]);return s=function(){return e},e}function p(){var e=u([""]);return p=function(){return e},e}function u(e,t){return t||(t=e.slice(0)),e.raw=t,e}function l(e){var t=e.children;return Object(o.d)(a.j,null,Object(o.d)(a.k,null,"Overview"),t)}var d=r.a.h4(p()),c=r.a.h5(s());function m(e){var t=e.content;return Object(o.d)("div",null,Object(o.d)(a.j,null,Object(o.d)(a.k,null,"Table of contents"),Object(o.d)("ul",null,t.map((function(e){return Object(o.d)("li",{style:{marginLeft:18*(e.level||0)},key:e.anchor},Object(o.d)("a",{href:"#"+e.anchor},e.heading))})))),t.map((function(e){var t=e.level?c:d;return Object(o.d)(a.j,{id:e.anchor,key:e.anchor},Object(o.d)(t,null,e.heading),e.content)})))}var h=r.a.span(i())},505:function(e,t,n){"use strict";n(102)("anchor",(function(e){return function(t){return e(this,"a","name",t)}}))}}]);
//# sourceMappingURL=component---src-pages-guides-server-interacting-with-express-tsx-0738b28162b1c66650c9.js.map