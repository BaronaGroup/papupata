{"version":3,"sources":["webpack:///./src/components/IncludeAvailableFromContext.tsx","webpack:///./src/components/api-components.tsx","webpack:///./src/pages/guides/server/implementing.tsx","webpack:///./src/components/guides.tsx"],"names":["IncludeAvailableFromContext","React","Section","styled","section","SectionHeading","h4","SubHeading","h5","ExampleCommonContainer","Purpose","children","AvailableFrom","version","Usage","Parameters","includeAvailableFrom","label","Provider","value","Parameter","name","dataType","availableFrom","useContext","MethodReturnType","Caveats","Examples","Example","language","ExampleCommon","TypeParameters","Row","tr","NameColumn","td","DefaultValueColumn","DescriptionColumn","AvailableFromColumn","TypeParameter","defaultValue","IndexPage","content","heading","anchor","to","Overview","Level0","Level1","GuideContent","map","child","style","marginLeft","level","key","href","Heading","id","FixedFont","span"],"mappings":"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","file":"component---src-pages-guides-server-implementing-tsx-e6820c00b92de7683b86.js","sourcesContent":["import * as React from 'react'\n\nexport const IncludeAvailableFromContext = React.createContext(false)\n","import styled from 'styled-components'\nimport React, { ReactNode } from 'react'\nimport { Code } from './Code'\nimport { IncludeAvailableFromContext } from './IncludeAvailableFromContext'\n\nexport const Section = styled.section``\nexport const SectionHeading = styled.h4``\nexport const SubHeading = styled.h5``\nexport const ExampleCommonContainer = styled.section`\n  padding: 15px 30px;\n  background: lightyellow;\n`\n\nexport const Purpose: React.FC = ({ children }) => {\n  return (\n    <Section>\n      <SectionHeading>Purpose</SectionHeading>\n      {children}\n    </Section>\n  )\n}\n\nexport type ValidVersions = '1.1.0' | '1.2.0' | '1.5.0' | '1.8.0'\nexport const AvailableFrom = ({ version }: { version: ValidVersions }) => {\n  return (\n    <Section>\n      <SectionHeading>Availability</SectionHeading>\n      This functionality is available from papupata version {version} onwards.\n    </Section>\n  )\n}\n\nexport const Usage: React.FC = ({ children }) => {\n  return (\n    <Section>\n      <SectionHeading>Usage</SectionHeading>\n      {children}\n    </Section>\n  )\n}\nexport const Parameters: React.FC<{ includeAvailableFrom?: boolean; label?: string }> = ({ children, includeAvailableFrom, label }) => {\n  return (\n    <Section>\n      <IncludeAvailableFromContext.Provider value={!!includeAvailableFrom}>\n        <SectionHeading>Parameters{label && `: ${label}`}</SectionHeading>\n        {children ? (\n          <table>\n            <thead>\n              <tr>\n                <th>Name</th>\n                <th>Type</th>\n                <th>Description</th>\n                {includeAvailableFrom && <th>Introduced in</th>}\n              </tr>\n            </thead>\n            <tbody>{children}</tbody>\n          </table>\n        ) : (\n          <p>There are no parameters.</p>\n        )}\n      </IncludeAvailableFromContext.Provider>\n    </Section>\n  )\n}\n\nexport const Parameter: React.FC<{ name: string; dataType: any; availableFrom?: ValidVersions }> = ({\n  children,\n  name,\n  dataType,\n  availableFrom = '1.0.0'\n}) => {\n  const includeAvailableFrom = React.useContext(IncludeAvailableFromContext)\n  return (\n    <tr>\n      <td>{name}</td>\n      <td>{dataType}</td>\n      <td>{children}</td>\n      {includeAvailableFrom && <td>{availableFrom}</td>}\n    </tr>\n  )\n}\n\nexport const MethodReturnType: React.FC = ({ children }) => {\n  return (\n    <Section>\n      <SectionHeading>Returns</SectionHeading>\n      {children}\n    </Section>\n  )\n}\n\nexport const Caveats: React.FC = ({ children }) => {\n  return (\n    <Section>\n      <SectionHeading>Caveats</SectionHeading>\n      {children}\n    </Section>\n  )\n}\nexport const Examples: React.FC<{ children: any }> = ({ children }) => {\n  return (\n    <Section>\n      <SectionHeading>Examples</SectionHeading>\n      {children}\n    </Section>\n  )\n}\n\nexport const Example: React.FC<{ label?: string; children: string }> = ({ children, label }) => {\n  return (\n    <>\n      {label && <SubHeading>{label}</SubHeading>}\n      <Code language={'typescript'}>{children}</Code>\n    </>\n  )\n}\n\nexport const ExampleCommon: React.FC<{ children: any }> = ({ children }) => {\n  return (\n    <ExampleCommonContainer>\n      <SubHeading>Common to examples below:</SubHeading>\n      {children}\n    </ExampleCommonContainer>\n  )\n}\n\nexport const TypeParameters: React.FC<{ children: ReactNode; includeAvailableFrom?: boolean }> = ({ children, includeAvailableFrom }) => {\n  return (\n    <Section>\n      <SectionHeading>Type parameeters</SectionHeading>\n      <IncludeAvailableFromContext.Provider value={!!includeAvailableFrom}>\n        <SectionHeading>Parameters</SectionHeading>\n        {children ? (\n          <table>\n            <thead>\n              <tr>\n                <th>Name</th>\n                <th>Default value</th>\n                <th>Description</th>\n                {includeAvailableFrom ? <th>Introduced in</th> : ''}\n              </tr>\n            </thead>\n            <tbody>{children}</tbody>\n          </table>\n        ) : (\n          <p>There are no parameters.</p>\n        )}\n      </IncludeAvailableFromContext.Provider>\n    </Section>\n  )\n}\n\nconst Row = styled.tr``\nconst NameColumn = styled.td``\nconst DefaultValueColumn = styled.td``\nconst DescriptionColumn = styled.td``\nconst AvailableFromColumn = styled.td``\n\nexport const TypeParameter: React.FC<{ name: string; defaultValue?: string; availableFrom?: string }> = ({\n  children,\n  name,\n  defaultValue,\n  availableFrom = 'none'\n}) => {\n  const includeAvailableFrom = React.useContext(IncludeAvailableFromContext)\n  return (\n    <Row>\n      <NameColumn>{name}</NameColumn>\n      <DefaultValueColumn>{defaultValue}</DefaultValueColumn>\n      <DescriptionColumn>{children}</DescriptionColumn>\n      {includeAvailableFrom ? <AvailableFromColumn>{availableFrom}</AvailableFromColumn> : ''}\n    </Row>\n  )\n}\n","import * as React from 'react'\n\nimport Page from '../../../components/Page'\nimport Container from '../../../components/Container'\nimport IndexLayout from '../../../layouts'\nimport { FixedFont, GuideContent, Overview } from '../../../components/guides'\nimport { Example } from '../../../components/api-components'\nimport { Link } from 'gatsby'\n\nconst IndexPage = () => (\n  <IndexLayout>\n    <Page>\n      <Container>\n        <h1>Guide: implementing APIs</h1>\n        <Overview>\n          When creating a server with papupata, the one thing you want is to be able to do is implementing the APIs. This guide help you\n          understand how that is done.\n        </Overview>\n        <GuideContent\n          content={[\n            {\n              heading: 'Prerequisites',\n              anchor: 'prerequisites',\n              content: (\n                <>\n                  <p>\n                    Before starting this guide, should have an API declaration set up to serve requests. This is covered in{' '}\n                    <Link to={'/guides/server/setup'}>the setup guide</Link>. You should also know how APIs are declared, see{' '}\n                    <Link to={'/guides/declaring'}>Declaring APIs</Link> for more details.\n                  </p>\n                  <p>Examples in this guide will use routes declared like this:</p>\n                  <Example>{`\n                  const complexAPI = API.declarePostAPI('/update/:id', routeOptions)\n                    .params(['id'] as const)\n                    .query(['author'] as const)\n                    .optionalQuery(['timestamp'] as const)\n                    .queryBool(['notifyWatchers'] as const)\n                    .body<{ name: string}>()\n                    .response<{status: string }>()\n                  `}</Example>\n                </>\n              )\n            },\n\n            {\n              heading: 'The basics',\n              anchor: 'basics',\n              content: (\n                <>\n                  <p>When it comes to just implementing APIs, it is quite simple:</p>\n                  <Example>{`\n                  complexAPI.implement(() => ({ status: 'hello' })\n                `}</Example>\n                  <p>\n                    Of course, in practice you'll want to utilize the parameters sent to the API, and possibly do asynchronous things.\n                    Luckily things like that are still quite easy.\n                  </p>\n                  <Example>{`\n                  complexAPI.implement(async req => ({\n                    await doSomethingComplex(req.params.id)\n                    return {status: 'ok!'}\n                  })\n                `}</Example>\n                  <p>\n                    So what exactly makes this interesting? Types! While you still access <FixedFont>params</FixedFont>,{' '}\n                    <FixedFont>query</FixedFont> and <FixedFont>body</FixedFont> from the request as you would with express, everything is\n                    typed. You cannot access query and path parameters that do not exist, the body has an explicit type, and even the value\n                    you return as the response is typed to ensure that whatever you return matches the declaration.\n                  </p>\n                  <p>\n                    The implementation is given three parameters: the express request modified for types, express response and the\n                    declaration for the route that is being implemented. The declaration is more useful in middleware, but sometimes you can\n                    re-use implementations for multiple routes in which case it can be useful to be able to access the route options and to\n                    construct an URL to the same API, with different parameters.\n                  </p>\n                </>\n              )\n            },\n            {\n              heading: 'Passing the input data to other functions',\n              anchor: 'passingdata',\n              content: (\n                <>\n                  <p>It is often beneficial to split an implementation into multiple functions. But that can cause tricky type issues.</p>\n                  <Example>{`\n                complexAPI.implement(myImplementation)\n\n                function myImplementation(req: ??): ?? {\n                  // What are the types here meant to be?\n                }\n                `}</Example>\n                  <p>\n                    A simple but somewhat naive way to solve this problem would be to copy the types from the API declaration. If things\n                    don't match, typescript compiler will give you error messages and that'll work. But doing so can cause a bunch of extra\n                    work whenever things change, since there can be many types that need to be changed.\n                  </p>\n                  <p>\n                    The smart way in most cases is to use types provided by papupata. Since objects cannot export types the syntax is a bit\n                    odd as <FixedFont>typeof</FixedFont> is needed, but there does not seem to be a cleaner way to handle this.\n                  </p>\n                  <Example>{`\n                complexAPI.implement(myImplementation)\n\n                function myImplementation(req: typeof complexAPI.RequestType): typeof complexAPI.ResponseType {\n                  // Now we have explicit types!\n                }\n                `}</Example>\n                  <p>\n                    For more information about accessing data about the APIs, see <Link to={'/guides/metadata'}>the metadata guide</Link>\n                  </p>\n                </>\n              )\n            },\n            {\n              heading: 'Middleware',\n              anchor: 'middleware',\n              content: (\n                <>\n                  <p>\n                    You can not only configure an API declaration to include middleware that is applied to all APIs within it, but\n                    individual APIs can have their own middleware as well. Both express and papupata middleware are supported; when both are\n                    present, express middleware is always run first. If this is a problem, it is easy to create a wrapper that runs express\n                    middeware as papupata middleware.\n                  </p>\n                  <Example>{`\n                  complexAPI.implementWithExpressMiddleware([handleAuthentication], implementation)\n                  complexAPI.implementWithPapupataMiddleware([logRequests], implementation)\n                  complexAPI.implementWithMiddleware({\n                    express: [handleAuthentication],\n                    papupata: [logRequests]\n                  }, implementation)\n                  `}</Example>\n                  <p>\n                    See <Link to=\"/guides/server/middleware\">the middleware guide</Link> for more information about middleware.\n                  </p>\n                </>\n              )\n            },\n            {\n              heading: 'Not actually implementing routes',\n              anchor: 'notimplementing',\n              content: (\n                <>\n                  <p>\n                    Sometimes routing can work in ways where there are false positives. You might for example only want to run API actions\n                    with certain headers present, such as\n                  </p>\n                  <Example>{`\n                  Accept: application/json\n                `}</Example>\n                  <p>\n                    Usually you'd want to do this kind of filtering with a middleware, but perhaps you have an API with unique behavior. You\n                    can have the implementation indicate that routing should be restarted past the API you are in, accomplishing what you\n                    can with express by calling <FixedFont>next</FixedFont> in the implementation.\n                  </p>\n                  <Example>{`\n                    import {skipHandlingRoute} from 'papupata'\n                    complexAPI.implement(req => {\n                      if (!req.headers['accept']?.includes('application/json')) {\n                        return skipHandlingRoute\n                      }\n                      // actual implementation here\n                    }\n                  `}</Example>\n                </>\n              )\n            },\n            {\n              heading: 'Error handling',\n              anchor: 'errorhandling',\n              content: (\n                <>\n                  <p>\n                    Papupata does not do much in terms of error handling. Any exceptions thrown in the implementations can be caught\n                    middleware, but that not happen, the error is passed to express.\n                  </p>\n                  <p>\n                    In other words, you'll want to have either express or papupata middleware to deal with the errors. There is no type\n                    information for errors at this time.\n                  </p>\n                  <Example>{`\n                  function errorMiddleware(req, res, _route, next) {\n                    try {\n                      await next()\n                    } catch(err) {\n                      console.error(err.stack || err.message || err)\n                      res.status(500)\n                      return 'Something went boom'\n                    }\n                  }\n\n                  complexAPI.implementWithPapupataMiddleware([errorMiddleware], () => { throw new Error() })\n                  `}</Example>\n                </>\n              )\n            },\n            {\n              heading: 'Conclusion',\n              anchor: 'conclusion',\n              content: (\n                <>\n                  <p>You now know enough to implement all kinds of APIs with papupata, at least for simple use cases.</p>\n                  <p>\n                    <Link to={'/guides/server/middleware'}>Understanding middleware</Link> can be quite helpful for dealing with more\n                    complex cases, or if you already have an application using express, you might want to learn more about{' '}\n                    <Link to={'/guides/server/interactingWithExpress'}>how express and papupata interact</Link>.\n                  </p>\n                  <p>\n                    Tests are an essential part of any serious code base, so learning about{' '}\n                    <Link to=\"/guides/server/testing\">testing papupata APIs</Link> is sure to be useful, too.\n                  </p>\n                  <p>\n                    On the other hand, since you now know how to implement the APIs, maybe this would be a good moment to learn about how to\n                    call them? <Link to={'guides/client/setup'}>Setting up papupata client</Link> and{' '}\n                    <Link to={'guides/client/calling'}>calling APIs with papupata</Link> lead towards that direction.\n                  </p>\n                </>\n              )\n            }\n          ]}\n        />\n      </Container>\n    </Page>\n  </IndexLayout>\n)\n\nexport default IndexPage\n","import React, { ReactNode } from 'react'\nimport { Section, SectionHeading } from './api-components'\nimport styled from 'styled-components'\n\nexport function Overview({ children }: { children: ReactNode }) {\n  return (\n    <Section>\n      <SectionHeading>Overview</SectionHeading>\n      {children}\n    </Section>\n  )\n}\n\ninterface GuidePart {\n  heading: ReactNode\n  anchor: string\n  content: ReactNode\n  level?: number\n}\n\nconst Level0 = styled.h4``\nconst Level1 = styled.h5`\n  font-size: 1.1em;\n`\n\nexport function GuideContent({ content }: { content: GuidePart[] }) {\n  return (\n    <div>\n      <Section>\n        <SectionHeading>Table of contents</SectionHeading>\n        <ul>\n          {content.map((child) => (\n            <li style={{ marginLeft: 18 * (child.level || 0) }} key={child.anchor}>\n              <a href={`#${child.anchor}`}>{child.heading}</a>\n            </li>\n          ))}\n        </ul>\n      </Section>\n      {content.map((child) => {\n        const Heading = !child.level ? Level0 : Level1\n        return (\n          <Section id={child.anchor} key={child.anchor}>\n            <Heading>{child.heading}</Heading>\n            {child.content}\n          </Section>\n        )\n      })}\n    </div>\n  )\n}\n\nexport const FixedFont = styled.span`\n  font-family: 'Consolas', 'Bitstream Vera Sans Mono', 'Courier New', Courier, monospace;\n`\n"],"sourceRoot":""}